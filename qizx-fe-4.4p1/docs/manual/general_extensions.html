<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;12.&nbsp;General XQuery extension functions</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.1"><link rel="start" href="index.html" title="Qizx Manual"><link rel="up" href="reference.html" title="Part&nbsp;IV.&nbsp;Reference"><link rel="prev" href="reference.html" title="Part&nbsp;IV.&nbsp;Reference"><link rel="next" href="fulltext_extensions.html" title="Chapter&nbsp;13.&nbsp;Full-text XQuery extension functions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;12.&nbsp;General XQuery extension functions</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="reference.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;IV.&nbsp;Reference</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="fulltext_extensions.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="general_extensions"></a>Chapter&nbsp;12.&nbsp;General XQuery extension functions</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="general_extensions.html#d0e9289">1. Serialization</a></span></dt><dd><dl><dt><span class="sect2"><a href="general_extensions.html#d0e9292">1.1. Serialization to XML, HTML, XHTML, plain text</a></span></dt><dt><span class="sect2"><a href="general_extensions.html#d0e9477">1.2. JSON Serialization</a></span></dt></dl></dd><dt><span class="sect1"><a href="general_extensions.html#d0e9575">2. Parsing</a></span></dt><dd><dl><dt><span class="sect2"><a href="general_extensions.html#d0e9578">2.1. XML Parsing</a></span></dt><dt><span class="sect2"><a href="general_extensions.html#d0e9610">2.2. Semi-structured Content Parsing</a></span></dt><dd><dl><dt><span class="sect3"><a href="general_extensions.html#d0e9715">2.2.1. JSON parser</a></span></dt><dt><span class="sect3"><a href="general_extensions.html#d0e9785">2.2.2. HTML parser</a></span></dt><dt><span class="sect3"><a href="general_extensions.html#d0e9850">2.2.3. HTML5 parser</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="general_extensions.html#d0e9882">3. XSL Transformation</a></span></dt><dt><span class="sect1"><a href="general_extensions.html#d0e10022">4. Dynamic evaluation</a></span></dt><dt><span class="sect1"><a href="general_extensions.html#d0e10067">5. Query extensions</a></span></dt><dd><dl><dt><span class="sect2"><a href="general_extensions.html#d0e10070">5.1. Estimated count and pagination</a></span></dt><dt><span class="sect2"><a href="general_extensions.html#d0e10186">5.2. Pattern-matching</a></span></dt><dt><span class="sect2"><a href="general_extensions.html#d0e10275">5.3. Range testing</a></span></dt></dl></dd><dt><span class="sect1"><a href="general_extensions.html#d0e10381">6. Date and Time</a></span></dt><dd><dl><dt><span class="sect2"><a href="general_extensions.html#d0e10384">6.1. Differences with W3C specifications</a></span></dt><dt><span class="sect2"><a href="general_extensions.html#d0e10389">6.2. Cast Extensions</a></span></dt><dt><span class="sect2"><a href="general_extensions.html#d0e10450">6.3. Additional constructors</a></span></dt><dt><span class="sect2"><a href="general_extensions.html#d0e10535">6.4. Additional accessors</a></span></dt></dl></dd><dt><span class="sect1"><a href="general_extensions.html#d0e10715">7. Error handling</a></span></dt></dl></div><p>These general purpose functions belong to the namespace denoted by the predefined "<code class="literal">x:</code>" prefix. The <code class="literal">x:</code> prefix refers to namespace "<code class="literal">com.qizx.functions.ext</code>".</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9289"></a>1.&nbsp;Serialization</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9292"></a>1.1.&nbsp;Serialization to XML, HTML, XHTML, plain text</h3></div></div></div><p><em class="glossterm">Serialization</em> &#8212; the process of converting XML nodes into a stream of characters &#8212; is defined in XQuery 1.0 Specifications, however there is no standard function for performing serialization.</p><p><code class="function">x:serialize</code> can output a document or a node into XML, HTML, XHTML or plain text, to a file or to the default output stream.</p><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">x:serialize( <em class="replaceable"><code>$node</code></em> as&nbsp;node(), <em class="replaceable"><code>$options</code></em> as&nbsp;element(option) )
  as&nbsp;xs:string?</pre></span></dt><dd><p><b>Description:&nbsp;</b>Serializes the element and all its content into text. The output can be a file (see options below).</p><p><b>Parameter <em class="replaceable"><code>$tree</code></em>:&nbsp;</b>a XML tree to be serialized to text.</p><p><b>Parameter <em class="replaceable"><code>$options</code></em>:&nbsp;</b>an element bearing options in the form of attributes: see below.</p><p><b>Returned value:&nbsp;</b>The path of the output file if specified, otherwise the serialized result.</p><p>The options argument (which may be absent) has the form of an element of name "options" whose attributes are used to specify different options. For example:</p><pre class="programlisting">x:serialize( $doc,
             &lt;options output="out\doc.xml"
                      encoding="ISO-8859-1" indent="yes"/&gt;)</pre><p>This mechanism is similar to XSLT's xsl:output specification and is very convenient since the options can be computed or extracted from a XML document.</p><div class="table"><a name="serial_options_table"></a><p class="title"><b>Table&nbsp;12.1.&nbsp;Implemented serialization options</b></p><div class="table-contents"><table summary="Implemented serialization options" border="1"><colgroup><col width="28%" align="left"><col width="29%"><col width="43%"></colgroup><thead><tr><th align="left">option name</th><th align="left">values</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">method</td><td>XML (default) XHTML, HTML, or TEXT</td><td>output method</td></tr><tr><td align="left">output / file</td><td>a file path</td><td>output file. If this option is not specified, the generated text is returned as a string.</td></tr><tr><td align="left">version</td><td>default "1.0"</td><td>version generated in the XML declaration. No validity check.</td></tr><tr><td align="left">standalone</td><td>"yes" or "no".</td><td>No check is performed.</td></tr><tr><td align="left">encoding</td><td>must be the name of an encoding supported by the JRE.</td><td>The name supplied is generated in the XML declaration. If different than UTF-8, it forces the output of the XML declaration.</td></tr><tr><td align="left">indent</td><td>"yes" or "no" (default "no").</td><td>output indented.</td></tr><tr><td align="left">indent-value <span class="emphasis"><em>(extension)</em></span></td><td>integer value</td><td>specifies the number of space characters used for indentation.</td></tr><tr><td align="left">omit-xml-declaration</td><td>"yes" or "no" (default "no").</td><td>controls the output of a XML declaration.</td></tr><tr><td align="left">include-content-type</td><td>"yes" or "no" (default "no").</td><td>for XHTML and HTML methods, if the value is "yes", a META element specifying the content type is added at the beginning of element HEAD.</td></tr><tr><td align="left">escape-uri-attributes</td><td>"yes" or "no" (default "yes").</td><td>for XHTML and HTML methods, escapes <em class="firstterm">URI attributes</em> (i.e specific HTML attributes whose value is an URI).</td></tr><tr><td align="left">doctype-public</td><td>the public ID in the DOCTYPE declaration.</td><td>Triggers the output of the DOCTYPE declaration. Must be used together with the <code class="literal">doctype-system</code> option.</td></tr><tr><td align="left">doctype-system</td><td>the system ID in the DOCTYPE declaration.</td><td>Triggers the output of the DOCTYPE declaration.</td></tr><tr><td align="left">auto-dtd <span class="emphasis"><em>(extension)</em></span></td><td>"yes" or "no" (default "yes").</td><td><p>If the node is a document node and if this document has DTD information, then output a DOCTYPE declaration. </p><div class="itemizedlist"><ul type="disc"><li><p>A Document stored in an XML Library may have properties storing this information (dtd-system-id and dtd-public-id) initially set by import.</p></li><li><p>a parsed document gets DTD information from the XML parser.</p></li><li><p>a constructed node has no DTD information.</p></li></ul></div></td></tr></tbody></table></div></div><br class="table-break"><p>&nbsp;</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9477"></a>1.2.&nbsp;JSON Serialization</h3></div></div></div><p>This function transforms an XML tree representing JSON data into JSON format.</p><p>The XML JSON tree is typically built by the x:content-parse function but can also be built by XQuery constructor.</p><p>In future versions supporting XQuery 3.0 Maps and Arrays, this function will also be able to serialize such data into JSON format.</p><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">x:serialize-json( <em class="replaceable"><code>$json-data</code></em> as&nbsp;item(), <em class="replaceable"><code>$options</code></em> as&nbsp;element(option) )
  as&nbsp;xs:string?</pre></span></dt><dd><p><b>Description:&nbsp;</b>Serializes the element and all its content into JSON format. The output can be a file (see options below) or a string.</p><p><b>Parameter <em class="replaceable"><code>$tree</code></em>:&nbsp;</b>a XML tree representing JSON data to be serialized. This tree must conform with the JSON schema used by Qizx (see below).</p><p><b>Parameter <em class="replaceable"><code>$options</code></em>:&nbsp;</b>an element bearing options in the form of attributes: see below.</p><p><b>Returned value:&nbsp;</b>The path of the output file if specified, otherwise the serialized result.</p><p>The options argument (which may be absent) has the form of an element of name "options" whose attributes are used to specify different options. For example:</p><pre class="programlisting">x:serialize-json( $doc, &lt;options file="json.xml" /&gt;)</pre><p>with $doc holding a XML document representing JSON data in the Qizx/JSON representation:</p><pre class="programlisting">&lt;?xml version='1.0'?&gt;
&lt;map xmlns="com.qizx.json"&gt;
  &lt;pair name="a"&gt;
    &lt;number&gt;1.0&lt;/number&gt;
  &lt;/pair&gt;
  &lt;pair name="b"&gt;
    &lt;array&gt;
      &lt;boolean&gt;true&lt;/boolean&gt;
      &lt;string&gt;str&lt;/string&gt;
      &lt;map/&gt;
    &lt;/array&gt;
  &lt;/pair&gt;
  &lt;pair name="nothing"&gt;
    &lt;null/&gt;
  &lt;/pair&gt;
&lt;/map&gt;</pre><p>then the file json.xml will contain:</p><pre class="programlisting">{ "a": 1.0, "b": [ true, "str", {  } ], "nothing": null }</pre><div class="table"><a name="json_serial_options_table"></a><p class="title"><b>Table&nbsp;12.2.&nbsp;Implemented JSON serialization options</b></p><div class="table-contents"><table summary="Implemented JSON serialization options" border="1"><colgroup><col width="28%" align="left"><col width="29%"><col width="43%"></colgroup><thead><tr><th align="left">option name</th><th align="left">values</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">method</td><td>XML (default) XHTML, HTML, or TEXT</td><td>output method</td></tr><tr><td align="left">output / file</td><td>a file path</td><td>output file. If this option is not specified, the generated text is returned as a string.</td></tr><tr><td align="left">indent</td><td>integer value</td><td>specifies the number of space characters used for indentation.</td></tr></tbody></table></div></div><br class="table-break"><p>&nbsp;</p></dd></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9575"></a>2.&nbsp;Parsing</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9578"></a>2.1.&nbsp;XML Parsing</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">function x:parse($xml-text)
  as&nbsp;node()?</pre></span></dt><dd><p>Parses a string representing an XML document and returns a node built from that parsing. This can be useful for converting to a node a string from any origin.</p><p>Note that function x:eval could be used too (and it is more powerful, since any kind of node can be built with it), but there are some syntax differences: for example in x:eval, the curly braces <code class="code">{</code> and <code class="code">}</code> have to be escaped by duplicating them.</p><p><b>Parameter <em class="replaceable"><code>$xml-text</code></em>:&nbsp;</b>A well-formed XML document as a string.</p><p><b>Returned value:&nbsp;</b>A node of the Data Model if the string could be correctly parsed; the empty sequence if the argument was the empty sequence. An error is raised if there is a parsing error.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9610"></a>2.2.&nbsp;Semi-structured Content Parsing</h3></div></div></div><p>From version 4.2, Qizx offers a generic mechanism to plug <em class="glossterm">Content Importers</em>, i.e parsers of "semi-structured data", i.e data that is not XML, mais can easily transformed into XML representation, and then stored and manipulated in an XML database such as Qizx.</p><p>For example:</p><div class="itemizedlist"><ul type="disc"><li><p>various dialects of HTML can be transformed into XML. The resulting XML can be serialized back into HTML using the x:serialize function above.</p></li><li><p>JSON can be mapped into XML: Qizx offers a built-in facility for parsing JSON data, using a specific schema for its XML representation.</p></li><li><p>Parsers for other formats are planned after version 4.2: Mime Mail (RFC822), CSV, and probably some office formats like RTF.</p></li></ul></div><p></p><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">function x:parse-content($string, $format-name [, $options])
  as&nbsp;node()?</pre>, </span><span class="term"><pre class="synopsis">function x:content-parse($string, $format-name [, $options])
  as&nbsp;node()?</pre></span></dt><dd><p>Parses a string representing of some semi-structured data in the format specified by its name $format and returns a node built from that parsing.</p><p><span class="guibutton">Note</span>: content-parse is the old name for parse-content and will be deprecated.</p><p><b>Parameter <em class="replaceable"><code>$string</code></em>:&nbsp;</b>A well-formed XML document as a string.</p><p><b>Parameter <em class="replaceable"><code>$format-name</code></em>:&nbsp;</b>A string naming the Content Importer. For example "html", "json". The recognized names are described for each Content Importer.</p><p><b>Parameter <em class="replaceable"><code>$options</code></em>:&nbsp;</b>An XML node with an attribute for each option. For example <code class="code">&lt;options namespaces="true"/&gt;</code></p><p><b>Returned value:&nbsp;</b>A node of the Data Model if the string could be correctly parsed; the empty sequence if the argument was the empty sequence. An error is raised if there is a parsing error.</p></dd><dt><span class="term"><pre class="synopsis">function x:parse-url-content($url, $format-name [, $options])
  as&nbsp;node()?</pre></span></dt><dd><p>Parses semi-structured data located at $url, in the format specified by $format, and returns a node built from that parsing.</p><p><b>Parameter <em class="replaceable"><code>$url</code></em>:&nbsp;</b>A well-formed URL. Supported URL protocols currently are http: and file: (by default).</p><p><b>Parameter <em class="replaceable"><code>$format-name</code></em>:&nbsp;</b>A string naming the Content Importer. For example "html", "json". The recognized names are described for each Content Importer.</p><p><b>Parameter <em class="replaceable"><code>$options</code></em>:&nbsp;</b>An XML node with an attribute for each option. For example <code class="code">&lt;options namespaces="true"/&gt;</code></p><p><b>Returned value:&nbsp;</b>A node of the Data Model if the string could be correctly parsed; the empty sequence if the argument was the empty sequence. An error is raised if there is a parsing error.</p></dd></dl></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9715"></a>2.2.1.&nbsp;JSON parser</h4></div></div></div><div class="variablelist"><dl><dt><span class="term">format argument:</span></dt><dd><p>for invoking the JSON parser, the value of the $format-name argument is "json" or "text/json".</p></dd><dt><span class="term">Options</span></dt><dd><p>No options available to date.</p></dd><dt><span class="term">Generated XML</span></dt><dd><p>Example:</p><pre class="programlisting">x:content-parse('{ "a" : 1, b:[true, "str", {}], nothing:null}',
                "json")</pre><p>Produces</p><pre class="programlisting">&lt;?xml version='1.0'?&gt;
&lt;map xmlns="com.qizx.json"&gt;
  &lt;pair name="a"&gt;
    &lt;number&gt;1.0&lt;/number&gt;
  &lt;/pair&gt;
  &lt;pair name="b"&gt;
    &lt;array&gt;
      &lt;boolean&gt;true&lt;/boolean&gt;
      &lt;string&gt;str&lt;/string&gt;
      &lt;map/&gt;
    &lt;/array&gt;
  &lt;/pair&gt;
  &lt;pair name="nothing"&gt;
    &lt;null/&gt;
  &lt;/pair&gt;
&lt;/map&gt;</pre><p>Schema:</p><div class="itemizedlist"><ul type="disc"><li><p>A JSON map is represented by a <code class="code">map</code> element with as many children <code class="code">pair</code> elements as there are key-value pairs in the map.</p></li><li><p>A pair element has an attribute name for the value of the key. Its child element represents the value.</p></li><li><p>A JSON array is represented by a <code class="code">array</code> element with as many children elements as there are array items.</p></li><li><p>JSON values are trivially represented as elements <code class="code">boolean</code>, <code class="code">number</code>, <code class="code">string</code>.</p></li><li><p>A JSON null value is represented by the empty element <code class="code">null</code>.</p></li><li><p>All elements use the namespace "com.qizx.json".</p></li></ul></div></dd></dl></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9785"></a>2.2.2.&nbsp;HTML parser</h4></div></div></div><p>HTML parsing is performed by the TagSoup parser, allowing parsing "as it is found in the wild", i.e possibly malformed.</p><div class="variablelist"><dl><dt><span class="term">format argument:</span></dt><dd><p>for invoking the HTML parser, the value of the $format-name argument is "html" or "text/html".</p></dd><dt><span class="term">Options</span></dt><dd><p>Recognizable options are either TagSoup option, or a short name for SAX features.</p><p>TagSoup options:</p><div class="itemizedlist"><ul type="disc"><li><p>"ignore-bogons": A value of "true" indicates that the parser will ignore unknown elements.</p></li><li><p>"bogons-empty ": A value of "true" indicates that the parser will give unknown elements a content model of EMPTY; a value of "false", a content model of ANY.</p></li><li><p>"root-bogons" : A value of "true" indicates that the parser will allow unknown elements to be the root of the output document.</p></li><li><p>"default-attributes": A value of "true" indicates that the parser will return default attribute values for missing attributes that have default values.</p></li><li><p>"translate-colons: A value of "true" indicates that the parser will translate colons into underscores in names.</p></li><li><p>"restart-elements": A value of "true" indicates that the parser will attempt to restart the restartable elements.</p></li><li><p>i"gnorable-whitespace": A value of "true" indicates that the parser will transmit whitespace in element-only content via the SAX ignorableWhitespace callback. Normally this is not done, because HTML is an SGML application and SGML suppresses such whitespace.</p></li><li><p>"cdata-elements": A value of "true" indicates that the parser will process the script and style elements (or any elements with type='cdata' in the TSSL schema) as SGML CDATA elements (that is, no markup is recognized except the matching end-tag).</p></li></ul></div><p>SAX features:</p><p>Short names are used: for example "namespaces" is a short name for "http://xml.org/sax/features/namespaces".</p><div class="itemizedlist"><ul type="disc"><li><p>"namespaces"</p></li><li><p>"namespace-prefixes"</p></li><li><p>"external-general-entities"</p></li><li><p>"external-parameter-entities"</p></li><li><p>etc... see the documentation of TagSoup.</p></li></ul></div></dd></dl></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9850"></a>2.2.3.&nbsp;HTML5 parser</h4></div></div></div><p>HTML5 parsing is performed by the parser by Henri Sivonen and Mozilla Foundation (c) 2007-2010.</p><div class="variablelist"><dl><dt><span class="term">format argument:</span></dt><dd><p>for invoking the HTML parser, the value of the $format-name argument is "html5" or "text/html5".</p></dd><dt><span class="term">Options</span></dt><dd><p>In addition to SAX features (short names), recognizable options are:</p><div class="itemizedlist"><ul type="disc"><li><p>"unicode-normalization-checking"</p></li><li><p>"html4-mode-compatible-with-xhtml1-schemata"</p></li><li><p>"mapping-lang-to-xml-lang"</p></li><li><p>"scripting-enabled"</p></li></ul></div></dd></dl></div><p></p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9882"></a>3.&nbsp;XSL Transformation</h2></div></div></div><p>The<code class="function"> x:transform</code> function invokes a XSLT style-sheet on a node and can retrieve the results of the transformation as a tree, or let the style-sheet output the results.</p><p>This is a useful feature when one wants to transform a document (for example extracted from the XML Libraries) or a computed fragment of XML into different output formats like HTML, XSL-FO etc.</p><p>This example generates the transformed document <code class="varname">$doc</code> into a file <code class="filename">out\doc.xml</code>:</p><pre class="programlisting">x:transform( $doc, "ssheet1.xsl",
             &lt;parameters param1="one" param2="two"/&gt;,
             &lt;options output-file="out\doc.xml" indent="yes"/&gt;)</pre><p>The next example returns a new document tree. Suppose we have this very simple stylesheet which renames the element "<code class="literal">doc</code>" into "<code class="literal">newdoc</code>":</p><pre class="programlisting">&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                 version ="1.0" &gt;
  &lt;xsl:template match="doc"&gt;
     &lt;newdoc&gt;&lt;xsl:apply-templates/&gt;&lt;/newdoc&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre><p>The following XQuery expression:</p><pre class="programlisting">x:transform( &lt;doc&gt;text&lt;/doc&gt;, "ssheet1.xsl", &lt;parameters/&gt; )</pre><p>returns:</p><pre class="programlisting">&lt;newdoc&gt;text&lt;/newdoc&gt;</pre><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">x:transform( <em class="replaceable"><code>$source</code></em> as&nbsp;node(), 
             <em class="replaceable"><code>$stylesheet-URI</code></em> as&nbsp;xs:string, 
             <em class="replaceable"><code>$xslt-parameters</code></em> as&nbsp;element(parameters) 
             [, <em class="replaceable"><code>$options</code></em> as&nbsp;element(options)] )
  as&nbsp;node()?</pre></span></dt><dd><p>Transforms the source tree through a XSLT stylesheet. If no output file is explicitly specified in the options, the function returns a new tree.</p><p><b>Parameter <em class="replaceable"><code>$source</code></em>:&nbsp;</b>a XML tree to be transformed. It does not need to be a complete document.</p><p><b>Parameter <em class="replaceable"><code>$stylesheet-URI</code></em>:&nbsp;</b>the URI of a XSLT stylesheet. Stylesheets are cached and reused for consecutive transformations.</p><p><b>Parameter <em class="replaceable"><code>$xslt-parameters</code></em>:&nbsp;</b>an element holding parameter values to pass to the XSLT engine. The parameters are specified in the form of attributes. The name of an attribute matches the name of a <code class="sgmltag-element">xsl:param</code> declaration in the stylesheet (namespaces can be used). The value of the attribute is passed to the XSLT transformer.</p><p><b>Parameter <em class="replaceable"><code>$options</code></em>:&nbsp;</b>[optional argument] an element holding options in the form of attributes: see below.</p><p><b>Returned value:&nbsp;</b>if the path of an output file is not specified in the options, the function returns a new document tree which is the result of the transformation of the source tree. Otherwise, it returns the empty sequence.</p><div class="table"><a name="d0e9980"></a><p class="title"><b>Table&nbsp;12.3.&nbsp;XSLT transform options</b></p><div class="table-contents"><table summary="XSLT transform options" border="1"><colgroup><col width="33%" align="left"><col width="22%"><col width="45%"></colgroup><thead><tr><th align="left">option name</th><th align="left">values</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">output-file</td><td>An absolute file path.</td><td>Output file. If this option is not specified, the generated tree is returned by the function, otherwise the function returns an empty sequence.</td></tr><tr><td align="left"><span class="emphasis"><em>XSLT output properties</em></span> (instruction xsl:output): version, standalone, encoding, indent, omit-xml-declaration etc.</td><td>&nbsp;</td><td>These options are used by the style-sheet for outputting the transformed document. They are ignored if no output-file option is specified.</td></tr><tr><td align="left">Specific options of the XSLT engine (Saxon or default XSLT engine)</td><td>&nbsp;</td><td>An invalid option may cause an error.</td></tr></tbody></table></div></div><br class="table-break"></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">About the efficiency of the connection with XSLT</h3><p>The connection with an XSLT engine uses generic JAXP interfaces, and thus must copy XML trees passed in both directions. This is not as efficient as it could be and can even cause memory problems if the size of processed documents is larger then a few dozen megabytes, depending on the available memory size.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10022"></a>4.&nbsp;Dynamic evaluation</h2></div></div></div><p>The following functions allow dynamically compiling and executing XQuery expressions.</p><div class="variablelist"><dl><dt><span class="term"><a name="dyn-eval"></a><pre class="synopsis">function x:eval( <em class="replaceable"><code>$expression</code></em> as&nbsp;xs:string )
  as&nbsp;xs:any</pre></span></dt><dd><p>Compiles and evaluates a simple expression provided as a string.</p><p>The expression is executed in the context of the current query: it can use global variables, functions and namespaces of the current static context. It can also use the current item '.' if defined in the evaluation context.</p><p>However there is no access to the local context (for example if <code class="function">x:eval</code> is invoked inside a function, the arguments or the local variables of the function are not visible.)</p><p><b>Parameter <em class="replaceable"><code>$expression</code></em>:&nbsp;</b>a simple expression (cannot contain prologue declarations).</p><p><b>Returned value:&nbsp;</b>evaluated value of the expression.</p><p>Example:</p><pre class="programlisting">declare variable $x := 1;
declare function local:fun($p as&nbsp;xs:integer) { $p * 2 };

let $expr := "1 + $x, local:fun(3)"
return x:eval($expr)</pre><p>This should return the sequence <code class="literal">(2, 6)</code>.</p></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10067"></a>5.&nbsp;Query extensions</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10070"></a>5.1.&nbsp;Estimated count and pagination</h3></div></div></div><p>The following functions can be used to quickly estimate the count of <span class="emphasis"><em>documents</em></span> returned by a query, when an exact count of all results would be too long to compute. They are designed to work on tens of millions of documents.</p><p>The estimated count provided by these functions is <span class="bold"><strong>valid under the following conditions</strong></span>:</p><div class="itemizedlist"><ul type="disc"><li><p>There is zero or one result ("hit") of the query per document The functions count <span class="emphasis"><em>documents</em></span>, not nodes.</p></li><li><p>The query is applied to an homogeneous domain (a collection, typically): that is, each document in the domain has a chance to match the query (or in other terms, the domain does not contain documents that cannot match the query, and would only distort the count estimation).</p></li></ul></div><p>Examples: assume collection /Products (the domain) contains only documents whose main node is 'Product'.</p><p>The estimated count in the following example would be the size of collection('/Products'):</p><pre class="programlisting">x:count-estimate(collection('/Products')//Product)</pre><p>In the following example the function looks at the first result items and estimates the total number by extrapolation: this would be a fraction of the the size of the domain represented by <code class="computeroutput">collection('/Products')</code>. The accuracy can be controlled by an optional parameter (see below):</p><pre class="programlisting">x:count-estimate(collection('/Products')//Product [ price &gt; 10 ])</pre><h4><a name="d0e10106"></a>Functions:</h4><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">function x:count-estimate( <em class="replaceable"><code>$</code></em>query [, $min-count as&nbsp;xs:integer ])
  as&nbsp;xs:boolean</pre></span></dt><dd><p>Returns an estimated count of documents matching the query.</p><p><b>Parameter <em class="replaceable"><code>$query</code></em>:&nbsp;</b>any query that matches one node per document at most. Should be an expression, which is evaluated within the x:count-estimate function. Passing an already evaluated sequence brings no profit.</p><p><b>Parameter <em class="replaceable"><code>$min-count</code></em>:&nbsp;</b>Optional (default value is 200). Controls the accuracy of the count estimation. This is the number of result items enumerated before doing the estimation. The estimated count is then obtained by comparing the current position in the search domain to the size of the domain, and extrapolating. A larger $min-count gives a better accuracy, but can lead to slower execution.</p><p><b>Returned value:&nbsp;</b>an integer item. If smaller than $min-count, this value represents the exact count. Otherwise the value is strongly rounded to provide a precision of about 10% (for example 11000 instead of 10653).</p></dd><dt><span class="term"><pre class="synopsis">function x:paged-query( $page-start&nbsp;as&nbsp;xs:integer, $page-size&nbsp;as&nbsp;xs:integer, $query [, $min-count&nbsp;as&nbsp;xs:integer ])
  as&nbsp;xs:boolean</pre></span></dt><dd><p>Similar to x:count-estimate() but in addition returns a "page" of result items.</p><p>This function could be implemented with x:count-estimate() and subsequence($query, $page-start, $page-size), but it combines the two operations in a slightly more efficient way.</p><p><b>Parameter <em class="replaceable"><code>$query</code></em>:&nbsp;</b>any query that matches one node per document at most. This expression is in fact a function (or "lambda expression") passed to the x:paged-query function itself. Passing an expression already evaluated (e.g using a variable) would bring no profit.</p><p><b>Parameter <em class="replaceable"><code>$page-start</code></em>:&nbsp;</b>The desired start position in the result sequence.</p><p><b>Parameter <em class="replaceable"><code>$page-size</code></em>:&nbsp;</b>The desired number of result items.</p><p><b>Parameter <em class="replaceable"><code>$min-count</code></em>:&nbsp;</b>Optional (default value is 200). Controls the accuracy of the count estimation. This is the number of result items enumerated before doing the estimation. The estimated count is then obtained by comparing the current position in the search domain to the size of the domain, and extrapolating. A larger $min-count gives a better accuracy, but can lead to slower execution.</p><p><b>Returned value:&nbsp;</b>A sequence made of: first an integer item which is the estimated count, exactly like in x:count-estimate() , then the items of the page.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10186"></a>5.2.&nbsp;Pattern-matching</h3></div></div></div><p>The following functions match the string-value of nodes (elements and attributes) with a pattern.</p><p>Example&nbsp;1: this expression returns true if the value of the attribute @lang matches the SQL-style pattern:</p><pre class="programlisting">x:like( "en%", $node/@lang )</pre><p>Example&nbsp;2: this expression returns true if the content of the element 'NAME' matches the pattern:</p><pre class="programlisting">$p/NAME[ x:like( "Theo%" ) ]</pre><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">function x:like( <em class="replaceable"><code>$pattern</code></em>&nbsp;as&nbsp;xs:string [, $context-nodes as&nbsp;node()* ])
  as&nbsp;xs:boolean</pre></span></dt><dd><p>Returns true if the pattern matches the string-value of at least one node in the node sequence argument.</p><p><b>Parameter <em class="replaceable"><code>$pattern</code></em>:&nbsp;</b>a SQL-style pattern: the wildcard '<code class="literal">_</code>' matches any single character, the wildcard '<code class="literal">%</code>' matches any sequence of characters.</p><p><b>Parameter <em class="replaceable"><code>$context-nodes</code></em>:&nbsp;</b>optional sequence of nodes. The function checks sequentially the string-value of each node against the pattern. If absent, the argument default to '<code class="literal">.</code>', the current item. This makes sense inside a predicate, like in the example 2 above.</p><p><b>Returned value:&nbsp;</b>a boolean.</p></dd><dt><span class="term"><pre class="synopsis">function x:ulike( <em class="replaceable"><code>$pattern</code></em>&nbsp;as&nbsp;xs:string [, <em class="replaceable"><code>$context-nodes</code></em> as&nbsp;node()* ])
  as&nbsp;xs:boolean</pre></span></dt><dd><p>This function is very similar to <code class="function">x:like</code>, except that the pattern has syntax &agrave; la Unix ("glob pattern"). The character '<code class="literal">?</code>' is used instead of '<code class="literal">_</code>' (single character match), and '<code class="literal">*</code>' instead of '<code class="literal">%</code>' (multi-character match).</p></dd></dl></div><p><span class="bold"><strong>Note</strong></span>: these functions &#8212; as well as the standard <code class="function">fn:matches</code> function, and the full-text functions &#8212; are automatically recognized by the query optimizer which uses library indexes to boost their execution whenever possible.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10275"></a>5.3.&nbsp;Range testing</h3></div></div></div><p>This function allows testing if a item belongs to a range, in a optimized way.</p><p>This function is used typically to optimize a predicate in a Library query, for example</p><pre class="programlisting"> //element[&nbsp;x:in-range(@weight,&nbsp;1,&nbsp;10)&nbsp;] </pre><p>which is equivalent to</p><pre class="programlisting"><code class="code">//element[ @weight&nbsp;&gt;=&nbsp;1&nbsp;and&nbsp;@weight&nbsp;&lt;=&nbsp;10 ]</code></pre><p>The reason for this function is that the query optimizer is not able to detect such a double test in all situations. The function could become useless in later versions of Qizx, after improvement of the query optimizer.</p><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">function x:in-range( $value, $low-bound as&nbsp;item(), $high-bound as&nbsp;item() )
  as&nbsp;xs:boolean

function x:in-range( $value, $low-bound as&nbsp;item(), $high-bound as&nbsp;item(), 
                     $low-included as&nbsp;xs:boolean,
                     $high-included as&nbsp;xs:boolean )
  as&nbsp;xs:boolean</pre></span></dt><dd><p>Returns true if at least one item from the sequence <em class="replaceable"><code>$value</code></em> belongs to the range defined by other parameters.</p><p><b>Parameter <em class="replaceable"><code>$value</code></em>:&nbsp;</b>Any sequence of items. Items must be comparable to the bounds, otherwise a type error is raised.</p><p><b>Parameters <em class="replaceable"><code>$low-bound</code></em>, <em class="replaceable"><code>$high-bound</code></em>:&nbsp;</b>Lower and upper bounds of the range. They must be of compatible types.</p><p><b>Parameters <em class="replaceable"><code>$low-included</code></em>:&nbsp;</b>If <em class="replaceable"><code>$low-included</code></em> is equal to <code class="function">true()</code>, the comparison used is <code class="code">$low-bound&nbsp;&lt;=&nbsp;$value</code>, otherwise <code class="code">$low-bound&nbsp;&lt;&nbsp;$value</code>. If absent, <code class="code">&lt;=</code> is assumed.</p><p><b>Parameters <em class="replaceable"><code>$high-included</code></em>:&nbsp;</b>If <em class="replaceable"><code>$high-included</code></em> is equal to <code class="function">true()</code>, the comparison used is <code class="code">$value&nbsp;&lt;=&nbsp;$high-bound</code>, otherwise <code class="code">$value&nbsp;&lt;&nbsp;$high-bound</code>. If absent, <code class="code">&lt;=</code> is assumed.</p><p><b>Returned value:&nbsp;</b>True if at least one item from the sequence <em class="replaceable"><code>$value</code></em> belongs to the range defined by <em class="replaceable"><code>$low-bound</code></em>, <em class="replaceable"><code>$high-bound</code></em>.</p></dd></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10381"></a>6.&nbsp;Date and Time</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10384"></a>6.1.&nbsp;Differences with W3C specifications</h3></div></div></div><p>Qizx is compliant with the W3C Recommendation. The only differences at present are extensions of the cast operation: Qizx can directly cast date, time, dateTime and durations to and from double values representing seconds, and keeps the extended "constructors" that build date, dateTime, etc, from numeric components like days, hours, minutes, etc.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10389"></a>6.2.&nbsp;Cast Extensions</h3></div></div></div><p>In order to make computations easier, Qizx can:</p><div class="itemizedlist"><ul type="disc"><li><p>Cast <code class="literal">xdt:yearMonthDuration</code> to numeric values: this yields the number of months. The following expression returns 13:</p><pre class="programlisting">xdt:yearMonthDuration("P1Y1M") cast as&nbsp;xs:integer</pre></li><li><p>Conversely, cast numeric value representing months to <code class="literal">xdt:yearMonthDuration</code>. The following expression holds true:</p><pre class="programlisting">xdt:yearMonthDuration(13) = xdt:yearMonthDuration("P1Y1M")</pre></li><li><p>Cast <code class="literal">xdt:daytimeDuration</code> to double: this yields the number of seconds. The following expression returns 7201:</p><pre class="programlisting">xdt:dayTimeDuration("PT2H1S") cast as&nbsp;xs:double</pre></li><li><p>Conversely, cast a numeric value representing seconds to <code class="literal">xdt:daytimeDuration</code>.</p></li><li><p>Cast <code class="literal">xs:dateTime</code> to double. This returns the number of seconds elapsed since ``the Epoch'', i.e. 1970-01-01T00:00:00Z. If the timezone is not specified, it is considered to be UTC (GMT).</p></li><li><p>Conversely, cast a numeric value representing seconds from the origin to a dateTime with GMT timezone.</p></li><li><p>cast from/to the <code class="literal">xs:date</code> type in a similar way (like a dateTime with time equal to 00:00:00).</p><pre class="programlisting">xdt:date("1970-01-02") cast as&nbsp;xs:double = 86400</pre></li><li><p>cast from/to the <code class="literal">xs:time</code> type in a similar way (seconds from 00:00:00).</p><pre class="programlisting">xdt:time("01:00:00") cast as&nbsp;xs:double = 3600</pre></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10450"></a>6.3.&nbsp;Additional constructors</h3></div></div></div><p>These constructors allow date, time, dateTime objects to be built from numeric components (this is quite useful in practice).</p><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">function xs:date( <em class="replaceable"><code>$year</code></em>&nbsp;as&nbsp;xs:integer,
                  <em class="replaceable"><code>$month</code></em>&nbsp;as&nbsp;xs:integer,
                  <em class="replaceable"><code>$day</code></em>&nbsp;as&nbsp;xs:integer )
  as&nbsp;xs:date</pre></span></dt><dd><p>Builds a <code class="literal">xs:date</code> from a year, a month, and a day in integer form. The implicit timezone is used.</p><p>For example <code class="code">xs:date(1999, 12, 31)</code> returns the same value as&nbsp;xs:<code class="code">date("1999-12-31")</code>.</p></dd><dt><span class="term"><pre class="synopsis">function xs:time( <em class="replaceable"><code>$hour</code></em>&nbsp;as&nbsp;xs:integer,
                  <em class="replaceable"><code>$minute</code></em>&nbsp;as&nbsp;xs:integer,
                  <em class="replaceable"><code>$second</code></em>&nbsp;as&nbsp;xs:double )
  as&nbsp;xs:time</pre></span></dt><dd><p>Builds a <code class="literal">xs:time</code> from an hour, a minute as integer, and seconds as double. The implicit timezone is used.</p></dd><dt><span class="term"><pre class="synopsis">function xs:dateTime( <em class="replaceable"><code>$year</code></em>&nbsp;as&nbsp;xs:integer, <em class="replaceable"><code>$month</code></em>&nbsp;as&nbsp;xs:integer, <em class="replaceable"><code>$day</code></em>&nbsp;as&nbsp;xs:integer, 
                      <em class="replaceable"><code>$hour</code></em>&nbsp;as&nbsp;xs:integer, <em class="replaceable"><code>$minute</code></em>&nbsp;as&nbsp;xs:integer, <em class="replaceable"><code>$second</code></em>&nbsp;as&nbsp;xs:double 
                      [, <em class="replaceable"><code>$timezone</code></em>&nbsp;as&nbsp;xs:double] )
  as&nbsp;xs:dateTime</pre></span></dt><dd><p>Builds a <code class="literal">xs:dateTime</code> from the six components that constitute date and time.</p><p>A timezone can be specified: it is expressed as a signed number of hours (ranging from -14 to 14), otherwise the implicit timezone is used.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10535"></a>6.4.&nbsp;Additional accessors</h3></div></div></div><p>These functions are kept for compatibility. They are slightly different than the standard functions:</p><div class="itemizedlist"><ul type="disc"><li><p>they accept several date/time and durations types for the argument (so for example we have get-minutes instead of get-minutes-from-time, get-minutes-from-dateTime etc.),</p></li><li><p>but they do not accept untypedAtomic (node contents): such an argument should be cast to the proper type before being used. So the standard function might be as convenient here.</p></li></ul></div><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">function get-seconds( <em class="replaceable"><code>$moment</code></em> )
  as&nbsp;xs:double?</pre></span></dt><dd><p>Returns the "second" component from a xs:time, xs:dateTime, and xs:duration.</p><p>Can replace fn:seconds-from-dateTime, fn:seconds-from-time, fn:seconds-from-duration, except that the returned type is double instead of decimal, and an argument of type xdt:untypedAtomic is not valid.</p></dd><dt><span class="term"><pre class="synopsis">function get-all-seconds( <em class="replaceable"><code>$duration</code></em> )
  as&nbsp;xs:double?</pre></span></dt><dd><p>Returns the total number of seconds from a xs:duration. This does not take into account months and years, as explained above.</p><p>For example <code class="code">get-all-seconds(xs:duration("P1YT1H"))</code> returns 3600.</p></dd><dt><span class="term"><pre class="synopsis">function get-minutes( <em class="replaceable"><code>$moment</code></em> )
  as&nbsp;xs:integer?</pre></span></dt><dd><p>Returns the "minute" component from a <code class="literal">xs:time</code>, <code class="literal">xs:dateTime</code>, and <code class="literal">xs:duration</code>.</p></dd><dt><span class="term"><pre class="synopsis">function get-hours( <em class="replaceable"><code>$moment</code></em> )
  as&nbsp;xs:integer?</pre></span></dt><dd><p>Returns the "hour" component from a <code class="literal">xs:time</code>, <code class="literal">xs:dateTime</code>, and <code class="literal">xs:duration</code>.</p></dd><dt><span class="term"><pre class="synopsis">function get-days( <em class="replaceable"><code>$moment</code></em> )
  as&nbsp;xs:integer?</pre></span></dt><dd><p>Returns the "day" component from a <code class="literal">xs:date</code>, <code class="literal">xs:dateTime</code>, <code class="literal">xs:day</code>, <code class="literal">xs:monthDay</code> and <code class="literal">xs:duration</code>.</p></dd><dt><span class="term"><pre class="synopsis">function get-months( <em class="replaceable"><code>$moment</code></em> )
  as&nbsp;xs:integer?</pre></span></dt><dd><p>Returns the "month" component from a <code class="literal">xs:date</code>, <code class="literal">xs:dateTime</code>, <code class="literal">xs:yearMonth</code>, <code class="literal">xs:month</code>, <code class="literal">xs:monthDay</code> and <code class="literal">xs:duration</code>.</p></dd><dt><span class="term"><pre class="synopsis">function get-years( <em class="replaceable"><code>$moment</code></em> )
  as&nbsp;xs:integer?</pre></span></dt><dd><p>Returns the "year" component from a <code class="literal">xs:date</code>, <code class="literal">xs:dateTime</code>, <code class="literal">xs:year</code>, <code class="literal">xs:yearMonth</code> and <code class="literal">xs:duration</code>.</p></dd><dt><span class="term"><pre class="synopsis">function get-timezone( <em class="replaceable"><code>$moment</code></em> )
  as&nbsp;xs:duration?</pre></span></dt><dd><p>Returns the "timezone" component from any date/time type and <code class="literal">xs:duration</code>.</p><p>The returned value is like <code class="function">timezone-from-*</code> except that the returned type is <code class="literal">xs:duration</code>, not <code class="literal">xdt:dayTimeDuration</code>.</p></dd></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10715"></a>7.&nbsp;Error handling</h2></div></div></div><p>Early versions of XQuery had no mechanism to handle run-time errors. Qizx introduced its own try/catch since the very first version.</p><p>Qizx now supports the standard try/catch defined in XQuery 3.0.</p><p>For the record, the try/catch construct provided by early versions of Qizx (still supported) is documented here:</p><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">try { <code class="exceptionname"><em class="replaceable"><code>expr</code></em></code> } catch(<em class="replaceable"><code>$error</code></em>) { <em class="replaceable"><code>fallback-expr</code></em> }</pre></span></dt><dd><p>The try/catch extended language construct first evaluates the body <em class="replaceable"><code>expr</code></em>. If no error occurs, then the result of the try/catch is the return value of this expression.</p><p>If an error occurs, the local variable <em class="replaceable"><code>$error</code></em> receives a string value which is the error message, and <em class="replaceable"><code>fallback-expr</code></em> is evaluated (with possible access to the error message). The resulting value of the try/catch is in this case the value of this fallback expression. An error in the evaluation of the fallback-expression is not caught.</p><p>The type of this expression is the type that encompasses the types of both arguments.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>The body (first expression) is guaranteed to be evaluated completely before exiting the try/catch - unless an error occurs. In other terms, lazy evaluation, which is used in most Qizx expressions, does not apply here.</p><p>This is specially important when functions with side-effects are called in the body. If such functions generate errors, these errors are caught by the try/catch, as one can expect. Otherwise lazy evaluation could produce strange effects.</p></div><p>Example: tries to open a document, returns an element <code class="sgmltag-element">error</code> with an attribute <code class="sgmltag-attribute">msg</code> containing the error message if the document cannot be opened.</p><pre class="programlisting">try {
    doc("unreachable.xml")
}
catch($err) {
    &lt;error msg="{$err}"/&gt;
}</pre></dd></dl></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="reference.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="reference.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="fulltext_extensions.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part&nbsp;IV.&nbsp;Reference&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;13.&nbsp;Full-text XQuery extension functions</td></tr></table></div></body></html>