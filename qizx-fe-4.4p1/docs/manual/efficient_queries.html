<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;11.&nbsp;Writing efficient queries</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.1"><link rel="start" href="index.html" title="Qizx Manual"><link rel="up" href="dev_guide.html" title="Part&nbsp;III.&nbsp;Developer's Guide"><link rel="prev" href="programming.html" title="Chapter&nbsp;10.&nbsp;Programming with the Qizx API"><link rel="next" href="reference.html" title="Part&nbsp;IV.&nbsp;Reference"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;11.&nbsp;Writing efficient queries</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="programming.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;III.&nbsp;Developer's Guide</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="reference.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="efficient_queries"></a>Chapter&nbsp;11.&nbsp;Writing efficient queries</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="efficient_queries.html#d0e8557">1. The problem</a></span></dt><dd><dl><dt><span class="section"><a href="efficient_queries.html#d0e8578">1.1. An example</a></span></dt></dl></dd><dt><span class="section"><a href="efficient_queries.html#d0e8686">2. Performance Guidelines</a></span></dt><dd><dl><dt><span class="section"><a href="efficient_queries.html#d0e8691">2.1. Text search</a></span></dt><dt><span class="section"><a href="efficient_queries.html#d0e8771">2.2. Path Expressions</a></span></dt><dd><dl><dt><span class="section"><a href="efficient_queries.html#d0e8835">2.2.1. Indexable features of Path expressions</a></span></dt><dt><span class="section"><a href="efficient_queries.html#d0e9150">2.2.2. Inefficient functions or expressions</a></span></dt></dl></dd><dt><span class="section"><a href="efficient_queries.html#d0e9226">2.3. Planned enhancements</a></span></dt></dl></dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8557"></a>1.&nbsp;The problem</h2></div></div></div><p>Qizx is a XML database engine designed for query speed. This is made possible by the underlying technology, and by a non-naive query compiler that takes advantage of indexes automatically. The result is that Qizx is really one the very fastest XML query engines available today, with nearly no need for intervention of the administrators or developers.</p><p>Nevertheless, it would be illusory to believe that the way queries are written has no influence on their execution speed. In general, however smart a compiler is, it cannot always compensate for unadapted or poorly written programs. This remark is relevant for classical programming languages like C or Java, so it is probably even more true for XQuery, which is a new and complex language and whose execution &#8212; like for any database language &#8212; is dependent on the actual data being queried.</p><p>Simply put, this chapter aims at helping you to answer this question: does my query contain some constructs that prevent Qizx from optimizing it?</p><p>Please note the following points::</p><div class="itemizedlist"><ul type="disc"><li><p>A fairly good knowledge of XML Query is desirable to fully understand the ideas exposed here.</p></li><li><p>These indications are applicable to Qizx. No representations are made about other XQuery implementations. However some suggestions simply represent common sense.</p></li><li><p>The query optimizer in Qizx will certainly be improved in the course of time, therefore some recommendations can become obsolete. It is recommended to read the updated version of this document coming with a new release.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8578"></a>1.1.&nbsp;An example</h3></div></div></div><p>To illustrate what has been told above, let's take a simple example:</p><p>The following query produces a simple report about tests performed by a particular agent named John.</p><pre class="programlisting">for $t in collection("/tests")/test[ agent = "John" ]
return &lt;test id="{ $t/id }"&gt;{ $t/date }&lt;/test&gt;</pre><div class="itemizedlist"><ul type="disc"><li><p>The collection named /tests contains a large number of documents describing individual tests performed on some device. It is part of a XML Library built and indexed by Qizx.</p></li><li><p>The main element of each document is named <code class="classname">test</code>. Each <code class="classname">test</code> element has</p><div class="itemizedlist"><ul type="circle" compact><li><p>a sub-element <code class="sgmltag-element">agent</code> which contains the name of the person who conducted the test</p></li><li><p>a sub-element <code class="sgmltag-element">id</code> which uniquely identifies the test</p></li><li><p>a sub-element <code class="sgmltag-element">date</code> giving the date of the test, etc.</p></li></ul></div></li></ul></div><p>Written as such, this query can be executed at optimal speed by Qizx.</p><p>Here are alternate ways of producing the same results, with variable efficacy:</p><div class="orderedlist"><ol type="1"><li><p>Use a where clause:</p><pre class="programlisting">for $t in collection("/tests")/test
  where $t/agent = "John"
return &lt;test id="{$t/id}"&gt;{ $t/date }&lt;/test&gt;</pre><p>This is equivalent to the first optimal query, because in fact the where clause <code class="code">$t/agent&nbsp;=&nbsp;"John"</code> is automatically transformed into a predicate <code class="code">[&nbsp;./agent&nbsp;=&nbsp;"John"&nbsp;]</code>.</p></li><li><p>Iterate on documents:</p><pre class="programlisting">let $docs as node() := collection("/tests")
for $doc in $docs
  where $doc/test/agent = "John"
return &lt;test id="{$doc/test/id}"&gt;{ $doc/test/date }&lt;/test&gt;</pre><p>This is <span class="emphasis"><em>very inefficient</em></span>, because <code class="code">collection("/tests")</code> has to be first expanded into a sequence of document nodes, then a separate query must be performed on each document. If the documents are small, this results in a dumb traversal taking no advantage of indexes. This example might look a bit contrived, but in practice such a situation can happen fairly easily.</p></li><li><p>Iterate on agent:</p><pre class="programlisting">(:  iterate on 'agent' instead of 'test'  :) 
for $t in collection("/tests")/test/agent
  where $t = "John"
return &lt;test id="{$t/../id}"&gt;{ $t/../date }&lt;/test&gt;</pre><p>Almost equivalent to the first optimal query, but the expressions <code class="code">$t/../id</code> and <code class="code">$t/../date</code> are a bit slower and unlikely to be optimized in future versions.</p></li><li><p>An example where the name of an element is provided as a parameter:</p><pre class="programlisting">for $t in collection("/tests")/*[ name() = $name and ./agent = "John" ]
return &lt;test id="{ $t/id }"&gt;{ $t/date }&lt;/test&gt;</pre><p>Assuming that <code class="varname">$name</code> contains the <code class="interfacename">QName</code> "<code class="literal">test</code>", this query is equivalent to the preceding ones. However here the compiler is not able to find the optimization, so this query will execute much more slowly than the others.</p><p>By the way, in this case dynamic evaluation can solve the problem efficiently. Let's build the query as a string, then evaluate it with the function <code class="function">x:eval</code> (an extension function) :</p><pre class="programlisting">for $t in x:eval(concat('collection("/tests")/', $name, '[ $t/agent = "John" ]'))
return &lt;test id="{$t/id}"&gt;{ $t/date }&lt;/test&gt;</pre></li></ol></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8686"></a>2.&nbsp;Performance Guidelines</h2></div></div></div><p>This section surveys the most important categories of expressions: Path expressions and text search.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8691"></a>2.1.&nbsp;Text search</h3></div></div></div><p><span class="emphasis"><em>Main advice: avoid using the function <code class="function">contains()</code> if possible.</em></span></p><p>The <code class="function">contains()</code> function is used to search <span class="emphasis"><em>any</em></span> string. Using contains on a document or an element node means that the text contents of the node has to be "flattened" first (in other words, all the pieces of text contained anywhere inside the node have to be concatenated) before performing a linear text search. This can be extremely slow on a large document or collection of documents.</p><p>Recommended practices:</p><div class="itemizedlist"><ul type="disc"><li><p>Use full-text functions/expressions when possible. Instead of searching <span class="emphasis"><em>any</em></span> string, you generally want to look for <span class="emphasis"><em>words</em></span>. The full-text functions rely on indexes and are very efficient.</p></li><li><p>If you definitely need to use <code class="function">contains()</code> &#8212; you look for specific characters &#8212; try to reduce the domain where the string is searched. For example instead of <code class="code">//CHAPTER[contains(.&nbsp;'x^2')]</code> that searches for '<code class="code">x^2</code>' in the whole <code class="sgmltag-element">CHAPTER</code> element, you would use <code class="code">//CHAPTER[contains(.//FORMULA,&nbsp;'x^2')]</code> because you know the searched string can appear only inside a <code class="sgmltag-element">FORMULA</code> element contained within the chapter.</p></li><li><p>To search for a full-text expression wherever inside documents, use something like:</p><pre class="programlisting">/*[ . ftcontains <span class="emphasis"><em>full_text_expression</em></span> ]</pre><p>But by all means not <code class="code">//*[.&nbsp;ftcontains <em class="replaceable"><code>...</code></em>]</code> with a double-slash. This would be utterly inefficient and can even end up with a <code class="classname">OutOfMemory</code> exception. In the same way avoid something like <code class="code">/elem/*[.&nbsp;ftcontains&nbsp;<em class="replaceable"><code>...</code></em>]</code> or <code class="code">/elem//*[.&nbsp;ftcontains&nbsp;<em class="replaceable"><code>...</code></em>]</code></p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8771"></a>2.2.&nbsp;Path Expressions</h3></div></div></div><div class="sidebar"><a name="path_expression_sidebar"></a><p class="title"><b>What is a Path Expression?</b></p><p>Path Expressions are XQuery/XPath expressions that use the '<code class="literal">/</code>' separator and return a sequence of nodes. They start from a root and produce nodes through one or several <span class="emphasis"><em>steps</em></span>. Returned nodes appear only once and are in <span class="emphasis"><em>document order</em></span>. Examples:</p><pre class="programlisting">collection("...")/test/agent[ name = "John" ]

$t/name</pre><p>A <em class="glossterm">relative Path</em> has no explicit root like <code class="function">collection()</code> or <code class="function">doc()</code> or variable name. It starts from the <span class="emphasis"><em>context node</em></span>, often noted by '<code class="literal">.</code>' (single dot). The context node, as the name says, is defined by the context, either the system initial conditions, or if inside a predicate, the node to which the predicate applies like in <code class="code">//item[ ./name&nbsp;=&nbsp;'John']</code> where '<code class="literal">.</code>' points out the '<code class="sgmltag-element">item</code>' current element.</p><p>A special case is a single <span class="emphasis"><em>step</em></span> like "<code class="code">CHAPTER</code>"or "<code class="code">node()</code>", where the slash operator does not appear but which is equivalent to <code class="code">./CHAPTER</code> or <code class="code">./node()</code> respectively.</p></div><p>Qizx generally does a good job with Path Expressions. It detects the parts of a path expression that can be optimized using indexes, compiles this parts into a fast-executing query, and evaluates the (possible) non-indexable remainder of the expression as a filter on the indexed query.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8835"></a>2.2.1.&nbsp;Indexable features of Path expressions</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>All XML elements are indexed, so using for example <code class="code">//CHAPTER</code> on a large collection is very efficient (no need to scan the entire collection).</p><p>This also applies to leaf nodes like <code class="code">comment()</code>, <code class="code">processing-instruction()</code> and <code class="code">text()</code>.</p></li><li><p>Element with simple contents matching a value.</p><p>For example in the predicate <code class="code">[&nbsp;agent="John"&nbsp;].</code></p><p>The match can be of several kinds:</p><div class="itemizedlist"><ul type="circle"><li><p>simple equality: <code class="literal">=</code> <code class="literal">eq</code></p></li><li><p>order comparison: <code class="literal">&lt;</code> <code class="literal">&lt;=</code> <code class="literal">&gt;</code> <code class="literal">&gt;=</code> <code class="literal">lt</code> <code class="literal">le</code> <code class="literal">gt</code> <code class="literal">ge</code></p></li><li><p>pattern matching functions on text <code class="function">fn:matches()</code>, <code class="function">x:like()</code> and <code class="function">x:ulike()</code>.</p></li><li><p>Note that the non-equal operator <code class="literal">!=</code> or <code class="literal">ne</code> cannot be indexed properly.</p></li></ul></div><p>The value of the element can be indexed in different types: string, number or date. So the test can involve numeric or date/dateTime values. See the chapter <a class="link" href="indexing.html" title="Chapter&nbsp;9.&nbsp;Configuring the indexing process">Configuring the indexing process</a> for more details about data conversions.</p><p>Notice that only <span class="emphasis"><em>simple</em></span> element contents are indexed: <code class="literal">&lt;operator&gt;Jo&lt;br/&gt;hn&lt;/operator&gt;</code> would not be matched by <code class="code">operator&nbsp;=&nbsp;"John"</code>.</p><p>Examples of predicates that use indexes in a path expression:</p><pre class="programlisting">[id = "id234"]

[./date &gt; xs:date("2003-01-01")]

[.//weight &gt; 10.5]

[x:like(name, "Al%")]

[matches(name, "Al[a-z]+")]</pre></li><li><p>Attributes matching a given value: similar to Element with simple contents.</p><p>Examples:</p><pre class="programlisting">test[ @id = "id234" ]

test[ @date &gt; xs:date("2003-01-01") ]

test[ @width &gt; 10 and @width &lt; 100 ]

test[ x:like(@name, "Al%") ]</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>inequality comparisons (<code class="literal">&gt;</code> <code class="literal">&gt;=</code> <code class="literal">&lt;</code> <code class="literal">&lt;=</code> <code class="literal">gt</code> <code class="literal">ge</code> <code class="literal">lt</code> <code class="literal">le</code>) can take significantly more time than equality.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A range comparison like @width &gt; 10 and @width &lt; 100 is not recognized as such, it is preferable to use the x:in-range function which is likely to be more efficient.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A predicate like x:like(., pattern) cannot be optimized if the first argument is '.' (current element). But this use is unlikely.</p></div></li><li><p>Full-text predicates:</p><pre class="programlisting">//SPEECH[ . ftcontains "romeo juliet" all words ]

//SPEECH[ . ftcontains "to be or not to be" ]</pre><p>See the <a class="link" href="fulltext_extensions.html" title="Chapter&nbsp;13.&nbsp;Full-text XQuery extension functions">Full-text extensions</a> for more information.</p></li><li><p>A combination of indexable steps using the <em class="firstterm">axes</em> <code class="literal">child::</code>, <code class="literal">descendant::</code> and <code class="literal">descendant-or-self::</code> , or the abbreviations '<code class="literal">/</code>' and '<code class="literal">//</code>'.</p><p>For example <code class="code">collection("/tests")/test[&nbsp;agent = "John"&nbsp;]</code> is fully indexed thus does not require to actually access the documents to be executed.</p><p>Note that <code class="literal">descendant</code> is as efficient as <code class="literal">child</code>, so specifying intermediate steps in a path will no make the query faster (rather the opposite!).</p><p>Examples:</p><pre class="programlisting">$root/x[@x = 1]//y/z[@y &lt;= 2]

$root/X//Z[ .//agent = "John" ]

$root(...)//X[ creation/@date &gt; xs:date("2003-01-01")]/Y[props/weight &gt; 10]

$root//test[ x:like(operator[@level &gt; 5], "Al%") ]</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Here the expression <code class="varname">$root</code> stands for any expression that can be used as the root of a path-expression, such as <code class="function">collection()</code> or <code class="function">doc()</code>.</p></div></li><li><p>A wildcard element name like in <code class="literal">child::*</code> can be optimized, but only if it is followed by an indexable step:</p><pre class="programlisting">$root/*[@x = 1]

$root/*/operator</pre><p>Therefore the following queries are not indexable:</p><pre class="programlisting">$root/*/*

$root//*</pre></li><li><p>An explicit path like <code class="code">/elem1/elem2/elem3</code> is <span class="emphasis"><em>not</em></span> more efficient than <code class="code">//elem3</code>. In fact it can be slightly less efficient.</p><p>Similarly, it is not useful to avoid using <code class="code">//</code> by writing something like <code class="code">/*/*/elem3</code> : the expression <code class="code">//elem3</code> is quite as fast.</p></li><li><p>The <code class="literal">and</code> connector in predicates is properly optimized.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Limitation</h3><p>A range test like<code class="code"> [&nbsp;10&nbsp;&lt;&nbsp;@width&nbsp;and&nbsp;@width&nbsp;&lt;&nbsp;100&nbsp;]</code> is currently not recognized as such, so it will evaluate much more slowly than if it were properly optimized. Therefore it is highly recommended to use the extension function <code class="function">x:in-range($item,&nbsp;$lower-bound,&nbsp;$upper-bound)</code>. In this example: <code class="code">[&nbsp;x:in-range(@width,&nbsp;10,&nbsp;100)&nbsp;]</code>.</p><p>Notice that the predicate <code class="code">[&nbsp;10&nbsp;&lt;&nbsp;child&nbsp;and&nbsp;child&nbsp;&lt;&nbsp;100&nbsp;]</code> is not strictly equivalent to <code class="code">[&nbsp;x:in-range(child,&nbsp;10,&nbsp;100) ]</code> when there are several children <code class="sgmltag-element">child</code> elements, so it cannot in principle be replaced automatically.</p></div></li><li><p>The <code class="literal">or</code> connector in predicates is also optimized.</p></li><li><p>A Path Expression used as a predicate is optimized. For example here is a query for a <code class="sgmltag-element">device</code> element that contains <span class="emphasis"><em>at least</em></span> one <code class="sgmltag-element">fault</code> element at any depth:</p><pre class="programlisting">$root/device[.//fault]</pre></li><li><p>The <code class="function">not()</code> and <code class="function">empty()</code> functions used in predicates are now optimized (as of version 3.0), when their argument can be indexed. Examples:</p><pre class="programlisting">$root/device[ not(empty(./fault)) ]</pre><pre class="programlisting">$root/device[ empty(fault) ]</pre></li><li><p>Similarly, predicates comparing <code class="function">count()</code> on a sub-path are optimized (as of version 3.0):</p><pre class="programlisting">$root/device[ count(./fault) &gt;= 3 ]</pre><pre class="programlisting">$root/device[ count(./fault) = 0 ]      (: similar to empty() :)</pre></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9150"></a>2.2.2.&nbsp;Inefficient functions or expressions</h4></div></div></div><p>Many language features that cannot be compiled to use indexes. Qizx tries to use indexes as much as possible, and leaves the non-indexable features to the plain XQuery interpreter.</p><p>Non-indexable features:</p><div class="itemizedlist"><ul type="disc"><li><p>In general, any expression, used as a predicate, which is not mentioned above is non-indexable.</p></li><li><p>Predicates containing <code class="function">position()</code> or <code class="function">last()</code>, explicitly or implicitly, like in <code class="code">child[2]</code> which is a short form for <code class="code">child[position()&nbsp;=&nbsp;2]</code>.</p><p>Since the semantics of these functions are dependent on the evaluation context, it is nearly impossible to index their values.</p><p>Function <code class="function">last()</code> can be a performance killer. Use with care.</p></li><li><p>Axes <code class="literal">ancestor::</code>, <code class="literal">ancestor-or-self::</code>, <code class="literal">parent::</code> or '<code class="literal"><span class="command"><strong>..</strong></span></code>', <code class="literal">preceding::</code>, <code class="literal">preceding-sibling::</code>, <code class="literal">following::</code>, <code class="literal">following-sibling::</code>.</p></li><li><p>Node tests like <code class="literal">node()</code> or <code class="literal">prefix:*</code>.</p></li><li><p>As suggested above, the '<code class="literal">*</code>' node test (meaning any element) cannot always be optimized. It is preferable to avoid using this wildcard when possible.</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9226"></a>2.3.&nbsp;Planned enhancements</h3></div></div></div><p>Expressions not currently optimized but which are likely to be optimized in next versions:</p><div class="itemizedlist"><ul type="disc"><li><p>Recognition of range test like <code class="code">10&nbsp;&lt;&nbsp;@width&nbsp;and&nbsp;@width&nbsp;&lt;&nbsp;100</code>.</p></li><li><p>Quantified expressions <code class="literal">some<em class="replaceable"><code>...</code></em>in<em class="replaceable"><code>...</code></em>satisfies<em class="replaceable"><code>...</code></em></code> and <code class="literal">every<em class="replaceable"><code>...</code></em>in<em class="replaceable"><code>...</code></em>satisfies<em class="replaceable"><code>...</code></em></code> used as predicate or where clause.</p></li><li><p>Predicates which are implicitly a join, like:</p><pre class="programlisting">for $t in collection("/invoices")/invoice,
    $c in collection("/clients")/client[ @id = $t/client-id ]
return ...</pre><p>This is equivalent to the following query, which is more obviously an equi-join:</p><pre class="programlisting">for $t in collection("/invoices")/invoice,
    $c in collection("/clients")/client
  where $c/@id = $t/client-id
return ...</pre></li></ul></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="programming.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="dev_guide.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="reference.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;10.&nbsp;Programming with the Qizx API&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;IV.&nbsp;Reference</td></tr></table></div></body></html>