<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;9.&nbsp;Configuring the indexing process</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.1"><link rel="start" href="index.html" title="Qizx Manual"><link rel="up" href="admin_guide.html" title="Part&nbsp;II.&nbsp;User's Guide"><link rel="prev" href="ch08.html" title="Chapter&nbsp;8.&nbsp;Support of EXPath Packages"><link rel="next" href="dev_guide.html" title="Part&nbsp;III.&nbsp;Developer's Guide"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;9.&nbsp;Configuring the indexing process</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch08.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;II.&nbsp;User's Guide</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="dev_guide.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="indexing"></a>Chapter&nbsp;9.&nbsp;Configuring the indexing process</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="indexing.html#d0e3993">1. Introduction</a></span></dt><dt><span class="section"><a href="indexing.html#d0e4051">2. Indexing in Qizx</a></span></dt><dd><dl><dt><span class="section"><a href="indexing.html#d0e4056">2.1. Indexes</a></span></dt><dt><span class="section"><a href="indexing.html#d0e4163">2.2. Indexing Specifications</a></span></dt><dd><dl><dt><span class="section"><a href="indexing.html#d0e4192">2.2.1. General structure of an Indexing Specification</a></span></dt><dt><span class="section"><a href="indexing.html#d0e4221">2.2.2. Global properties</a></span></dt><dt><span class="section"><a href="indexing.html#d0e4272">2.2.3. Conversion rules</a></span></dt><dt><span class="section"><a href="indexing.html#d0e4317">2.2.4. Rules for the conversion of simple element contents</a></span></dt><dt><span class="section"><a href="indexing.html#d0e4597">2.2.5. Rules for the conversion of attribute values</a></span></dt></dl></dd><dt><span class="section"><a href="indexing.html#d0e4615">2.3. Default Indexing Specification</a></span></dt></dl></dd><dt><span class="section"><a href="indexing.html#d0e4644">3. Configuring Indexing</a></span></dt><dd><dl><dt><span class="section"><a href="indexing.html#d0e4647">3.1. Writing a new Indexing Specification</a></span></dt><dt><span class="section"><a href="indexing.html#d0e4679">3.2. Changing the Indexing Specification of a Library</a></span></dt><dt><span class="section"><a href="indexing.html#d0e4765">3.3. Writing custom Sieves</a></span></dt></dl></dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3993"></a>1.&nbsp;Introduction</h2></div></div></div><p>Qizx uses indexes to greatly increase the speed of queries over XML Libraries.</p><p>By default, Qizx indexes most of the information available in XML documents: elements, attributes, other nodes, and full-text. This is done automatically, therefore <span class="emphasis"><em>in most cases there is no need for the database administrator to explicitly specify indexes</em></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In most other XML database engines, if you want to obtain an optimal or simply decent querying speed, you have to spend time defining specific indexes manually. Moreover when such a system is in production phase, if you need to optimize new queries, then you need to add new indexes, which means reindexing the whole database. Needless to say, this is problem-prone, time-consuming and costly.</p></div><p>You need to read this chapter only if you want to enhance or customize the indexing used by default in Qizx.</p><p>Qizx supports customization through an <em class="glossterm">Indexing Specification</em> associated with an XML Library. An Indexing Specification allows to:</p><div class="orderedlist"><ol type="1"><li><p>Modify or extend the conversions performed on the values of attributes and simple elements.</p><p>Qizx automatically recognizes and converts numeric and date values in attributes and simple elements, so that queries using those data types can be boosted by indexes, for example:</p><pre class="programlisting">//item[ weight = 10 ]

//event[ @date &gt;= xs:date("2007-12-31") ]</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><div class="itemizedlist"><ul type="disc"><li><p>This mechanism actually extends the XQuery language, since it allows number and date comparison even if the values in documents do not conform to the syntax of XML Schema types. For example, with a suitable indexing, the queries above could respectively match:</p><pre class="programlisting">&lt;item&gt;&lt;weight&gt;10.0Kg&lt;/weight&gt;...&lt;/item&gt;</pre><p>and:</p><pre class="programlisting">&lt;event date="12/31/2007"&gt;...&lt;/event&gt;</pre></li><li><p>The default conversions are compatible with the standard XQuery semantics.</p></li><li><p>This extension can currently be used only on documents stored in an XML Library. It is therefore not available in Qizx/open.</p></li></ul></div></div><p>The default conversions can be tuned or extended or suppressed, specific conversions can be added for specific contexts, custom converters can be plugged in Qizx.</p></li><li><p>Suppress full-text indexing where it is not needed. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>From v3.0, other full-text customization is achieved through the API.</p></div></li><li><p>Tune miscellaneous parameters, e.g the maximum length of indexed element values.</p></li></ol></div><p>The next section explains indexing in Qizx with more details, the following section explains how to configure this indexing.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4051"></a>2.&nbsp;Indexing in Qizx</h2></div></div></div><p>This section explains how indexing works in Qizx: what indexes are built, what are the default rules and conversions, what is an Indexing Specification.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4056"></a>2.1.&nbsp;Indexes</h3></div></div></div><p>Qizx creates and exploits the following indexes:</p><div class="variablelist"><dl><dt><span class="term">Element index</span></dt><dd><p>Given an element name, this index returns all XML elements in all documents of a Library that bear this name. It also contains information about structural relationships (child/descendant).</p></dd><dt><span class="term">Attribute indexes</span></dt><dd><p>Given an attribute name and a value, this index returns all elements that have an attribute with this name and value.</p><p>There are three types of attribute indexes, according to the type of the attribute value: text, numeric and date/time.</p><p>When indexing, Qizx attempts to convert attribute textual values into numeric or date values by using successively converters called "<em class="firstterm">Sieves</em>". These objects are pluggable and can be redefined, as explained in the following sections.</p><div class="itemizedlist"><ul type="disc"><li><p>By default, all attributes values are indexed as raw strings.</p></li><li><p>If the value can be converted to a double number, then it is added to the <em class="glossterm">numeric attribute index</em>.</p></li><li><p>If it can be converted to a date or date-time value, then it is added to the <em class="glossterm">date/time attribute index</em>.</p></li></ul></div><p>For example in an element instance like <code class="literal">&lt;elem&nbsp;num="12.0"&nbsp;date="12/31/2004"/&gt;</code>, the attribute <code class="sgmltag-attribute">num</code> is added to the numeric index and the attribute <code class="sgmltag-attribute">date</code> is added to the date/time index. The element <code class="sgmltag-element">elem</code> can thus be found by a query like <code class="code">elem[@num=12]</code> or <code class="code">elem[@date=xs:date("2004-12-31")]</code> (notice the non-string values in the queries).</p></dd><dt><span class="term">Simple content indexes</span></dt><dd><p>Given an element name and a value, this index returns all elements that have a <em class="glossterm">simple content</em> corresponding to this value.</p><p>Note: "simple content" is a sequence of characters which appears as the only contents of an element (by contrast with "mixed-content"). For example <code class="literal">&lt;e&gt;1234&lt;/e&gt;</code> is an element with a simple content.</p><p>By default, such a content is indexed <span class="emphasis"><em>if it is recognized as a "token"</em></span>, i.e some text without whitespace. For example the content of <code class="literal">&lt;e&gt;1234&lt;/e&gt;</code> is indexed as simple content but the content of <code class="literal">&lt;p&gt;this is a paragraph&lt;/p&gt;</code> is not (nevertheless the words inside element <code class="sgmltag-element">p</code> are put into the full-text index).</p><p>When recognized as a token, a simple content is indexed much in the same way as an attribute: numeric or date/time values are detected and added respectively to the <em class="glossterm">simple-content numeric index</em> and the <em class="glossterm">simple-content date/time index</em>. The default date pattern is the same as for attributes.</p></dd><dt><span class="term">Full-text index</span></dt><dd><p>Given a word, this index returns all the text nodes that contain an occurrence of this word.</p><p>Words are extracted from element contents using a "Word Sieve", which in addition normalizes the words (for example remove accents and converts the word to lowercase).</p><p>The Word Sieve is also used when parsing full-text queries. Consequently there can be only one word sieve per Library.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4163"></a>2.2.&nbsp;Indexing Specifications</h3></div></div></div><p>An <em class="glossterm">Indexing Specification</em> is associated with a XML Library. It applies to <span class="emphasis"><em>all</em></span> documents of the XML Library.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>as a consequence, if two documents have incompatible indexing requirements, they have to be stored in two different Libraries. However this is unlikely because Indexing Specifications allow fairly fine tuning.</p></div><p>Generally speaking, an <em class="glossterm">Indexing Specification</em> can contain:</p><div class="itemizedlist"><ul type="disc"><li><p>Values of general parameters.</p></li><li><p>Specifications for full-text indexing.</p></li><li><p>Rules for recognizing numeric and date values in element content and attributes.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4192"></a>2.2.1.&nbsp;General structure of an Indexing Specification</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>An indexing specification is an XML document.</p></li><li><p>The root element has the name <code class="sgmltag-element">indexing</code>.</p></li><li><p>The <code class="sgmltag-element">indexing</code> element bears attributes defining global properties.</p></li><li><p>It contains a list of <span class="emphasis"><em>rules</em></span> applicable to elements or to attributes.</p></li></ul></div><p>Example:</p><pre class="programlisting">&lt;indexing 
      word-min='1'
      word-max='30'
      string-max='50' 
      xmlns:my="http://www.acme.com/ns/my" &gt;

  &lt;!-- Rules for all elements. --&gt;
  &lt;element as="numeric+string" /&gt;
  &lt;element as="date" sieve="FormatDateSieve" format="yyyy-MM-dd" /&gt;
  &lt;element as="string" /&gt;

  &lt;!-- A specific rule for element NumData: disable full-text
       indexing inside this element. --&gt;
  &lt;element name="NumData" full-text="false" /&gt;

  &lt;!-- Rules for all attributes. --&gt;
  &lt;attribute /&gt;
  &lt;attribute as="numeric+string" /&gt;
  &lt;attribute as="date+string" /&gt;
  &lt;attribute as="string" /&gt;

  &lt;!-- A specific rule for attribute my:Date of element my:Invoice:
       its format is a localized date. --&gt;
  &lt;attribute name="my:Date" context="my:Invoice" 
             as="date" sieve="FormatDateSieve" format="MM/dd/yyyy" /&gt;

&lt;/indexing&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4221"></a>2.2.2.&nbsp;Global properties</h4></div></div></div><p>These properties apply globally to a specification. They appear as attributes of the top element <code class="sgmltag-element">indexing</code>:</p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-attribute">string-max</code></span></dt><dd><p>An integer value specifying the maximum length of a String key (default is 50). An element content or attribute value longer than this value is not indexed.</p><p>The purpose is to avoid cluttering the indexes with useless long values (like a complete paragraph).</p></dd><dt><span class="term"><code class="sgmltag-attribute">word-max</code></span></dt><dd><p>An integer value specifying the maximum length of a word in the full-text index (default is 30).</p><p>The purpose is to prevent long strings without whitespace to be treated like words if they are never to be searched in full-text mode.</p></dd><dt><span class="term"><code class="sgmltag-attribute">word-min</code></span></dt><dd><p>An integer value specifying the minimum length of a word in the full-text index (default is 2).</p><p>This is a simple way of supporting "stop words".</p></dd><dt><span class="term"><code class="sgmltag-attribute">word-sieve</code></span></dt><dd><p><span class="bold"><strong>Deprecated</strong></span>. From version 3.0, <em class="glossterm">Text Tokenizers</em> replace word sieves and are plugged through the Java API only. See section "<a class="link" href="indexing.html#customsifters">Custom Sieves</a>".</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4272"></a>2.2.3.&nbsp;Conversion rules</h4></div></div></div><p>How rules work:</p><div class="itemizedlist"><ul type="disc"><li><p>Each rule defines a conversion method from a text value (contained in a simple element, or in an attribute) to data types like number (double floating-point) and date.</p></li><li><p>For each text value to convert, rules are applied in sequence (from the most specific to the least specific).</p></li><li><p>When a rule succeeds (i.e its conversion method works on the text value considered), the converted value is stored in the indexes specified in the rule, and the conversion process for this text value finishes.</p></li></ul></div><p>A rule has different properties:</p><div class="itemizedlist"><ul type="disc"><li><p>Whether it applies to element content or to attribute values: the tag <code class="literal">&lt;element/&gt;</code> or <code class="literal">&lt;attribute/&gt;</code> is used respectively.</p></li><li><p>A <code class="sgmltag-attribute">name</code> and/or a <code class="sgmltag-attribute">context</code> (optional) to restrict the applicability of the rule to specific element/attribute names in a particular context of ancestor elements. Default rules &#8212; no name and no context &#8212; apply to all elements or attributes.</p></li><li><p>What are the target indexes: date, numeric, string or a combination.</p></li><li><p>The conversion method: this is called a <em class="firstterm">Sieve</em>, it is implemented by a Java class, and can be passed parameters.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4317"></a>2.2.4.&nbsp;Rules for the conversion of simple element contents</h4></div></div></div><p>Element rules generally serve to define how <em class="glossterm">simple element content</em> is indexed. They can also enable or disable full-text indexing through their attribute "full-text".</p><p>Element rules are specified in the indexing specification by an empty element named <code class="sgmltag-element">element</code>. Its properties are defined by attributes:</p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-attribute">name</code></span></dt><dd><p>When specified, the name indicates that the rule applies only to elements which have this name. The name can of course have a namespace prefix.</p><p>If the name is absent, the rule is a default rule applicable to all elements of documents to be indexed.</p></dd><dt><span class="term"><code class="sgmltag-attribute">context</code></span></dt><dd><p>It is a specification of ancestors of the element to which the rule applies.</p><div class="itemizedlist"><ul type="disc"><li><p>The element names are separated by a space or a slash. Names can have a namespace prefix.</p></li><li><p>A name can also be the wildcard '*' matching any element.</p></li><li><p>The rightmost name matches the parent, the leftmost matches the "oldest" ancestor, like in a XSLT pattern.</p></li></ul></div><p>Example: this rule applies to an element named <code class="sgmltag-element">birth-date,</code> child of <code class="sgmltag-element">customer</code> itself grand-child of <code class="sgmltag-element">invoice</code>:</p><pre class="programlisting">&lt;element name="birth-date" context="invoice/*/customer" 
         as="date" sieve="FormatDateSieve" format="MM/dd/yyyy" /&gt;</pre></dd><dt><span class="term"><code class="sgmltag-attribute">as</code></span></dt><dd><p>Specifies the target indexes. Possible values are:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="sgmltag-attvalue">date</code>: if the conversion to a date is possible (using a <code class="interfacename">DateSieve</code>, as explained hereafter), then the content is indexed as a date (Date Simple Content index), else this rule fails.</p></li><li><p><code class="sgmltag-attvalue">date+string</code> : same as date, but the contents is indexed both as a date and as a string value (Simple Content index).</p></li><li><p><code class="sgmltag-attvalue">number</code> : if the numeric conversion is possible (using a <code class="interfacename">NumberSieve</code>, as explained hereafter), then the content is indexed as a numeric value (Numeric Simple Content index), else this rule fails.</p></li><li><p><code class="sgmltag-attvalue">number+string</code> : same as number, but also index as string value.</p></li><li><p><code class="sgmltag-attvalue">string</code> : index as string value. This will never fail, so it must be the last applicable rule in a particular context.</p></li></ul></div></dd><dt><span class="term"><code class="sgmltag-attribute">sieve</code></span></dt><dd><p>Specifies an analyzer which performs conversion from string to number or date.</p><p>A rule where <code class="sgmltag-attribute">as</code> is <code class="sgmltag-attvalue">date</code> or <code class="sgmltag-attvalue">date+string</code> must specify a <code class="interfacename">DateSieve</code>; a rule where <code class="sgmltag-attribute">as</code> is <code class="sgmltag-attvalue">number</code> or <code class="sgmltag-attvalue">number+string</code> must specify a <code class="interfacename">NumberSieve</code>.</p><p>A predefined Sieve can be selected here, or it is possible to specify a custom Java class (See section "<a class="link" href="indexing.html#customsifters">Custom Sieves</a>".)</p><p>Parameters for sieves (predefined or custom) are specified as additional attributes of the rule.</p><p>Predefined Sieve classes.</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">sieve="FormatNumberSieve"</code> is the default when attribute <code class="sgmltag-attribute">as</code> specifies a numeric conversion.</p><p>Parameters:</p><div class="itemizedlist"><ul type="circle"><li><p>Optional parameter <code class="sgmltag-attribute">format</code> (as specified by <code class="classname">java.text.DecimalFormat</code>).</p><p>By default the format corresponds to double literals in the XQuery language, or to the xs:double type in XML Schema..</p></li><li><p>Optional parameter <code class="sgmltag-attribute">locale</code> specifies the locale for the format. Values accepted are similar to the values accepted by <code class="classname">java.util.Locale</code>, for example <code class="sgmltag-attvalue">en-US</code> or <code class="sgmltag-attvalue">de</code>.</p></li></ul></div><pre class="programlisting">&lt;element name="amount" context="invoice" as="numeric" format="000.0#" /&gt;</pre></li><li><p><code class="literal">sieve="ISODateSieve"</code> is the default when attribute <code class="sgmltag-attribute">as</code> specifies a date. This sieve accepts a type date or dateTime in ISO601 format, for example <code class="literal">2006-05-05</code> or <code class="literal">2006-05-05T12:30:00Z</code>.</p><p>There is no additional parameter.</p></li><li><p><code class="literal">sieve="FormatDateSieve"</code> specifies a date conversion with a format similar to patterns accepted by <code class="classname">java.text.SimpleDateFormat</code>.</p><p>Parameters:</p><div class="itemizedlist"><ul type="circle"><li><p>Optional parameter <code class="sgmltag-attribute">format</code> (as specified by <code class="classname">java.text.SimpleDateFormat</code>). By default the local ``short format'' is used (for example <code class="sgmltag-attvalue">MM/DD/YYYY</code> in US locale), and the time-zone is the default time-zone of the Java Runtime.</p></li><li><p>Optional parameter <code class="sgmltag-attribute">timezone</code> specifies the default time-zone for the sieve. Values accepted are similar to the values accepted by <code class="classname">java.util.TimeZone</code>.</p><p>Attention:</p></li><li><p>Optional parameter <code class="sgmltag-attribute">locale</code> specifies the locale for the format. Values accepted are similar to the values accepted by java.util.Locale, for example <code class="sgmltag-attvalue">en-US</code> or <code class="sgmltag-attvalue">de</code>.</p></li><li><p>Optional parameter <code class="sgmltag-attribute">lenient</code> accepts a boolean value (<code class="sgmltag-attvalue">true</code> or <code class="sgmltag-attvalue">false</code>). By default the sieve is not lenient: it accepts only values strictly matching the format.</p></li></ul></div><p>Example:</p><pre class="programlisting">&lt;element name="edit-date" as="date" 
         sieve="FormatDateSieve" format="yyyy-MM-dd" timezone="GMT-5" /&gt;</pre></li></ul></div></dd><dt><span class="term"><code class="sgmltag-attribute">full-text</code></span></dt><dd><p>Value is <code class="sgmltag-attvalue">yes</code> or <code class="sgmltag-attvalue">no</code>.</p><p>Full-text indexing is enabled by default for elements.</p><p>Setting <code class="sgmltag-attvalue">no</code> disables full-text indexing <span class="emphasis"><em>inside</em></span> the applicable element, that is, also for descendant elements (unless explicitly re-enabled).</p><p>Full-text can be re-enabled on descendant elements with a rule with <code class="literal">full-text="yes"</code>.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4597"></a>2.2.5.&nbsp;Rules for the conversion of attribute values</h4></div></div></div><p>Attribute rules are very similar to element rules.</p><p>The main difference is about full-text indexing:</p><div class="itemizedlist"><ul type="disc"><li><p>The full-text yes/no attribute is applicable only to the considered attribute.</p></li><li><p>Full-text indexing is not enabled for attributes by default.</p></li><li><p><span class="emphasis"><em>Actually, full-text search in attribute values is not yet supported in the current version of Qizx.</em></span></p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4615"></a>2.3.&nbsp;Default Indexing Specification</h3></div></div></div><p>The default indexing specification is set when creating a new XML Library. It can be written as follows:</p><pre class="programlisting">&lt;indexing&gt;
  &lt;element as="numeric+string"/&gt;
  &lt;element as="date+string" /&gt;
  &lt;element as="string" /&gt;

  &lt;attribute as="numeric+string" /&gt;
  &lt;attribute as="date+string" /&gt;
  &lt;attribute as="string" /&gt;
&lt;/indexing&gt;</pre><p>Interpretation:</p><div class="orderedlist"><ol type="1"><li><p>if a simple element content can be converted by the default numeric sieve [first element rule], then it is indexed both as a number and as a string,</p></li><li><p>else if its value can be converted by the default date sieve [second element rule], then it is indexed both as a date and as a string,</p></li><li><p>else it is indexed as a string if its length is less than the string-max parameter.</p></li></ol></div><p>The same for attributes.</p><p>Full-text indexing is enabled by default, and uses the default <code class="interfacename">TextTokenizer</code>.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>the default rules are not implicitly used when you write a new Indexing Specification (see below). That means that you have to explicitly copy these rules into your Indexing Specification if you want to use them.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4644"></a>3.&nbsp;Configuring Indexing</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4647"></a>3.1.&nbsp;Writing a new Indexing Specification</h3></div></div></div><p>In the current version of Qizx, simple Indexing Specifications can be edited using Qizx Studio. See below for more details.</p><p>In the general case, indexing specifications have to be written as an XML file and then stored into an XML Library (and then indexes should be rebuilt if necessary).</p><p>The recommended practice is to start from the default specification as provided above and add rules and/or modify default rules.</p><p>The following important points should be remembered:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>The default rules are not implicit</em></span>. That is, you have to copy these rules into your Indexing Specification if you want to use them. The reason is that you may want to not use some of these rules.</p></li><li><p>When performing queries on an XML Library, Qizx relies on the actual indexes of the Library. This means that if some information is not indexed, then the corresponding queries would <span class="emphasis"><em>return no result</em></span>.</p><p>Note: it would be unmanageable to use indexes in some parts of a Library, and a "fallback" strategy in some other parts.</p><p>For example if your Indexing Specification blocks indexing of numeric values, then a query like <code class="code">//good[@weight&nbsp;&gt;&nbsp;100]</code> will not work (because it relies on the numeric value of attribute 'weight').</p><p>Similarly, if your Indexing Specification blocks full-text indexing in some parts of documents, then a full-text query will find no result in those parts.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4679"></a>3.2.&nbsp;Changing the Indexing Specification of a Library</h3></div></div></div><p>The specification is stored in the Library. It is initialized when creating the library, then used automatically when documents are added.</p><div class="variablelist"><dl><dt><span class="term">Using the graphic interface Qizx Studio</span></dt><dd><p>Select the concerned Library.</p><p>Right-click and select "<span class="guisubmenu">Indexing</span>" in the menu, then "<span class="guimenuitem">Indexing Specification</span>" in the sub-menu.</p><p>This brings a dialog that allows you selecting the file containing the Indexing Specification. You can also use the button "<span class="guibutton">Restore Default</span>" to select the default rules.</p><p>When you push the button "<span class="guibutton">Change</span>", the specification is parsed and stored if valid.</p><p>Then you are suggested to rebuild the indexes entirely. This is highly recommended since the indexing rules have changed. If the Library is empty this is of course not necessary.</p></dd><dt><span class="term">Using the command-line tool qizx</span></dt><dd><p>Command line options for creating a new Library in a Library group with a custom Indexing Specification:</p><pre class="programlisting">qizx -group <em class="replaceable"><code>groupLocation</code></em> -library <em class="replaceable"><code>libName</code></em> -indexing <em class="replaceable"><code>specification</code></em> -create</pre><p>Here '<em class="replaceable"><code>groupLocation</code></em>' is the directory that contains the group of Libraries, '<em class="replaceable"><code>libName</code></em>' is the name of the Library to create and '<em class="replaceable"><code>specification</code></em>' is the path of a XML file that contains the specification.</p><p>Command line options for changing the Indexing Specification of an existing Library:</p><pre class="programlisting">qizx -group <em class="replaceable"><code>groupLocation</code></em> -library <em class="replaceable"><code>libName</code></em> -indexing <span class="emphasis"><em>specification</em></span> -reindex</pre><p>It is necessary to use the option <code class="option">-reindex</code> to rebuild the indexes, unless the Library contains no document.</p></dd><dt><span class="term">Through the API</span></dt><dd><p>See <a class="xref" href="programming.html#lesson_reindex" title="7.&nbsp;Customizing the indexing of XML content">Section&nbsp;7, &#8220;Customizing the indexing of XML content&#8221;</a>.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4765"></a>3.3.&nbsp;Writing custom Sieves</h3></div></div></div><h4><a name="d0e4768"></a>When is it necessary to write a custom Sieve?</h4><p>A custom Sieve is necessary if you want to index in numeric or date/time form some content, and the default Sieves provided with Qizx are not suitable:</p><div class="itemizedlist"><ul type="disc"><li><p>Numeric value: the value cannot be parsed by the Java class <code class="classname">java.text.DecimalFormat</code>.</p></li><li><p>Date/time value: the value cannot be parsed by <code class="classname">java.text.SimpleDateFormat</code> and is not an ISO date.</p></li><li><p>Full-text: you want more capabilities than provided by the default <code class="interfacename">TextTokenizer</code> (for example to handle a specific language). Full-text customization has changed in 3.0 and is achieved through the Java API: see the package <span class="package">com.qizx.api.fulltext</span> and its plug-in interface <code class="classname">FullTextFactory</code>.</p></li></ul></div><h4><a name="d0e4797"></a>Implementation information:</h4><p>As seen above, a custom sieve is specified by a <code class="classname">sieve</code> attribute in an element or attribute rule. The value of the <code class="classname">sieve</code> attribute is a fully qualified name of a Java class.</p><p>Custom Sieve Java classes must of course be accessible through the <code class="envar">CLASSPATH</code> of your application (or more exactly by its class loader) .</p><p>For more details, refer to the Java documentation of interfaces below and to the source code of default implementations (provided in the distribution).</p><div class="variablelist"><dl><dt><span class="term">Number Sieve</span></dt><dd><p>Must implement the interface <code class="interfacename">com.qizx.api.Indexing.NumberSieve</code>.</p><p>The default implementation is <code class="classname">com.qizx.util.text.FormatNumberSieve</code>.</p></dd><dt><span class="term">Date Sieve</span></dt><dd><p>Must implement the interface <code class="interfacename">com.qizx.api.Indexing.DateSieve</code>.</p><p>The default implementation is <code class="classname">com.qizx.util.text.ISODateSieve.</code></p><p><code class="classname">Another predefined implementation is com.qizx.util.text.FormatDateSieve</code> which is based on Java <code class="classname">SimpleDateFormat</code>.</p></dd></dl></div><p>Example:</p><pre class="programlisting">&lt;indexing word-sieve="com.mybusiness.xmlapp.WordSieve"&gt;
  &lt;element as="number" sieve="com.mybusiness.xmlapp.NumberSieve"/&gt;
  &lt;element as="date" sieve="com.mybusiness.xmlapp.DateSieve" param1="..." param2="..."/&gt;
  &lt;element as="token" /&gt;

  &lt;attribute as="number" sieve="com.mybusiness.xmlapp.NumberSieve"/&gt;
  &lt;attribute as="date" sieve="com.mybusiness.xmlapp.DateSieve"/&gt;
  &lt;attribute as="token" /&gt;
&lt;/indexing&gt;</pre></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch08.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="admin_guide.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="dev_guide.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;8.&nbsp;Support of EXPath Packages&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;III.&nbsp;Developer's Guide</td></tr></table></div></body></html>