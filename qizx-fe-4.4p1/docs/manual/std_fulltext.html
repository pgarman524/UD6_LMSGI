<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;7.&nbsp;Support of standard XQuery Full-Text</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.1"><link rel="start" href="index.html" title="Qizx Manual"><link rel="up" href="admin_guide.html" title="Part&nbsp;II.&nbsp;User's Guide"><link rel="prev" href="ch06.html" title="Chapter&nbsp;6.&nbsp;Support of standard XQuery Update"><link rel="next" href="ch08.html" title="Chapter&nbsp;8.&nbsp;Support of EXPath Packages"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;7.&nbsp;Support of standard XQuery Full-Text</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch06.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;II.&nbsp;User's Guide</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch08.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="std_fulltext"></a>Chapter&nbsp;7.&nbsp;Support of standard XQuery Full-Text</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="std_fulltext.html#fttutor">1. Tutorial Introduction to the standard XQuery Full-Text</a></span></dt><dt><span class="section"><a href="std_fulltext.html#d0e3264">2. Support of the XQuery Full-Text facilities in Qizx</a></span></dt><dd><dl><dt><span class="section"><a href="std_fulltext.html#d0e3294">2.1. Supported Features</a></span></dt><dt><span class="section"><a href="std_fulltext.html#d0e3416">2.2. Unsupported Features</a></span></dt><dt><span class="section"><a href="std_fulltext.html#d0e3438">2.3. Scoring</a></span></dt><dt><span class="section"><a href="std_fulltext.html#d0e3480">2.4. Tokenization</a></span></dt><dt><span class="section"><a href="std_fulltext.html#d0e3527">2.5. Other pluggable functionalities</a></span></dt></dl></dd><dt><span class="section"><a href="std_fulltext.html#fulltext-migration">3. Migration Guide from former Full-Text implementation</a></span></dt></dl></div><p>Starting from version 3.0, Qizx supports most of the new <a class="ulink" href="http://www.w3.org/TR/xpath-full-text-10/" target="_top">XQuery Full-Text candidate standard</a>.</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>The full-text facility existing in former versions is completely deprecated, and is no more available. A <a class="link" href="std_fulltext.html#fulltext-migration" title="3.&nbsp;Migration Guide from former Full-Text implementation">Migration guide</a> can be found at the end of this chapter.</p></div><p>The first section is an introduction to the Standard Full-Text (<acronym class="acronym">XQFT</acronym>). Since there is currently little literature about this new standard, except the specifications, we hope you will find this tutorial useful.</p><p>Support of the XQuery Full-Text facilities in Qizx is detailed in the second section.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fttutor"></a>1.&nbsp;Tutorial Introduction to the standard XQuery Full-Text</h2></div></div></div><p>This tutorial (<a class="ulink" href="http://www.xmlmind.com/_tutorials/XQueryFullText/" target="_top">http://www.xmlmind.com/_tutorials/XQueryFullText</a>), after a short presentation of main concepts, simply introduces main features through concrete examples.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3264"></a>2.&nbsp;Support of the XQuery Full-Text facilities in Qizx</h2></div></div></div><p>Qizx 3.0 supports a large part of mandatory and optional XQuery Full-Text features.</p><p>The two following chapters detail supported and unsupported features. To understand this section, it is recommended to have some acquaintance with XQFT, through <a class="ulink" href="http://www.w3.org/TR/xpath-full-text-10/" target="_top">W3C specifications</a> or by reading our <a class="ulink" href="http://www.xmlmind.com/_tutorials/XQueryUpdate/index.html" target="_top">tutorial</a>.</p><p>Qizx now supports many full-text features, but some capabilities -&nbsp;namely stemming and thesaurus&nbsp;- are highly language-specific and can only be supported by specialized extensions.</p><p>To offer the best language support, Qizx full-text can be extended through the Java API. It is possible to plug objects supporting:</p><div class="itemizedlist"><ul type="disc"><li><p>Text Tokenization (see below).</p></li><li><p>Stemming (but no implementation is available by default).</p></li><li><p>Thesaurus lookup (no implementation is available by default).</p></li><li><p>Scoring: score computation can be redefined by plugging another Scorer.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3294"></a>2.1.&nbsp;Supported Features</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Scoring: see dedicated section below.</p></li><li><p>Operator <span class="command"><strong>not in</strong></span>: supported.</p></li><li><p>Operator <span class="command"><strong>ftnot</strong></span>: fully supported.</p></li><li><p>Order (keyword <span class="command"><strong>ordered</strong></span>): fully supported.</p></li><li><p>Cardinality (<span class="command"><strong>occurs</strong></span> ... <span class="command"><strong>times</strong></span>): fully supported.</p></li><li><p>Proximity (keywords <span class="command"><strong>window</strong></span> and <span class="command"><strong>distance</strong></span>): support of the "words" unit.</p></li><li><p>Ignore (keyword <span class="command"><strong>without content</strong></span>) is supported, except some corner cases.</p></li><li><p>Language:</p><p>The language if specified is used for finding a Text Tokenizer (see below), for stemming and in Thesaurus lookup.</p><p>In the API, the related methods of the class FullTextFactory have a <em class="parameter"><code>language</code></em> argument.</p></li><li><p>Case sensitivity (option '<span class="command"><strong>case sensitive</strong></span>').</p><p>Note: queries using this feature can be significantly slower, especially if a large number of documents are searched.</p></li><li><p>Diacritic characters sensitivity (option '<span class="command"><strong>diacritics sensitive</strong></span>').</p><p>Note: queries using this feature can be significantly slower, especially if a large number of documents are searched.</p></li><li><p>Wildcards (option '<span class="command"><strong>with wildcards</strong></span>').</p><p>Note: looking up indexes for matches of a wildcard is normally quite fast (depending on the size of indexes of course). A wildcard character in first position (e.g "<span class="command"><strong>.*tion</strong></span>") can induce a measurable overhead (typically a few tens of milliseconds).</p></li><li><p>Stemming: (option '<span class="command"><strong>with stemming</strong></span>')</p><p>Supported, but no stemmer is available by default. Stemmers can be plugged through the API (see below)</p><p>Mixing Stemming and Case Sensitivity is not guaranteed to return proper results, as stemmers can fold the case.</p></li><li><p>Thesaurus (option '<span class="command"><strong>with thesaurus</strong></span>').</p><p>Supported, but no Thesaurus available by default. Thesaurus drivers can be plugged through the API (see below).</p></li></ul></div><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>Some combinations of operators and options have unspecified or unclear meanings, therefore no guaranty can be given about the results returned.</p><p>Examples:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="computeroutput">("yellow" ftor "red") distance at least 3 words</code></p><p>Does not make sense since the distance cannot be computed if only one of the two words is present.</p></li><li><p><code class="computeroutput">"York" ftand ftnot "New" window 2 words</code></p><p>Could be interpreted as an occurrence of "York" without "New" around. This is however questionable in terms of semantics and has to be clarified in the specifications.</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3416"></a>2.2.&nbsp;Unsupported Features</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Window and Distance "<em class="glossterm">big units</em>" ("sentence" and "paragraph"). Might be supported in the future.</p></li><li><p><em class="glossterm">Scope</em> ("same sentence", "different paragraph" etc). Might be supported in the future.</p></li><li><p><em class="glossterm">Stop-words</em>:</p><p>We regard stop-words as a feature from the past, only useful when it was important to reduce the size of indexes.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3438"></a>2.3.&nbsp;Scoring</h3></div></div></div><p>Scoring in Qizx is document-based. This means that all matched nodes belonging to a given document get the same score.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Computing scores on a node basis is a new concept, not yet well understood. In addition, that would probably be costly in terms of computation time. It is possible that future versions of Qizx optionally offer node-based scoring.</p></div><p>Score computation for a document relies on two values associated with each term (word) of a query:</p><div class="itemizedlist"><ul type="disc"><li><p>Relative term frequency in a document: the frequency of the word in the document divided by the average frequency in all documents. So if a term is more frequent in the considered document than the average, the score will be higher for that document.</p></li><li><p>Inverse Document Frequency: the total number of documents divided by the number of documents that contain the term. When a term is present in a smaller number of documents, it is considered more relevant and gets a higher score.</p></li></ul></div><p>The exact formulas used for computing the score are defined by a pluggable object, implementing the interface <code class="interfacename">com.qizx.api.fulltext.Scorer</code>.</p><h4><a name="d0e3460"></a>Built-in scoring:</h4><div class="itemizedlist"><ul type="disc"><li><p>The default scorer is implemented by class com.<code class="interfacename">qizx.api.util.fulltext.DefaultScorer</code>.</p></li><li><p>The default scorer no longer supports <span class="emphasis"><em>document ranking</em></span> through a metadata property "<code class="literal">ft-weight</code>" set on a Document.</p><p>This feature has been disabled in 3.1 because it makes scoring too slow. Future versions will provide a faster mechanism, plus features for fast heuristic scoring on very large document sets.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3480"></a>2.4.&nbsp;Tokenization</h3></div></div></div><p>Tokenization is the process of chunking text into "words", here called "tokens". It is in general very language-specific.</p><div class="itemizedlist"><ul type="disc"><li><p>Tokenizers can be plugged through the API. See package <span class="package">com.qizx.api.fulltext</span> .</p></li><li><p>The Qizx distribution contains a generic Tokenizer that works with most Western languages, without taking into account linguistic particularities.</p></li><li><p>Overlapping tokens ares not supported.</p><p>Overlapping tokens would happen for example with a composed word like "new-born", if one insists indexing both the whole word <span class="emphasis"><em>new-born</em></span> and each of the two words <span class="emphasis"><em>new</em></span> and <span class="emphasis"><em>born</em></span>.</p><p>The recommended practice is to always separate composed words into simple words, for example to treat the dash as a whitespace. This will work correctly both in indexing and queries. In some languages, like German for example, this might be a difficult task and requires using a dictionary.</p></li><li><p>A token is not allowed to span element boundaries.</p><p>A situation where a word is split by an element boundary seems very unusual, the only example we can think of is an element used to mark a "drop cap" or initial letter in a paragraph, like in:</p><pre class="programlisting">&lt;p&gt;&lt;big&gt;<span class="bold"><strong>O</strong></span>&lt;/big&gt;<span class="bold"><strong>nce</strong></span> upon a time...&lt;/p&gt;</pre><p>but that is definitely not a good idea.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3527"></a>2.5.&nbsp;Other pluggable functionalities</h3></div></div></div><p>Qizx full-text can be extended through the Java API. This allows plugging language-specific functionalities such as Stemming and Thesaurus (for tokenization, please previous section).</p><div class="itemizedlist"><ul type="disc"><li><p>The Java package <span class="package">com.qizx.api.fulltext</span> contains several interfaces defining extension points. The package <span class="package">com.qizx.api.util.fulltext</span> contains basic implementations.</p><p>For more information please read the javadocumentation of these interfaces and classes.</p></li><li><p>Plugging is performed through interface <code class="interfacename">com.qizx.api.fulltext.FullTextFactory</code>, which creates other objects like tokenizers, Scorers, Stemmers, Thesaurus drivers.</p><p>A new implementation of FullTextFactory can be set on each <code class="interfacename">Library</code> or <code class="interfacename">XQuerySession</code> interface. Notice that an implementation set for querying has to be consistent with the FullTextFactory used for indexing documents, in order to get meaningful results, in particular the same Tokenizer should be used (i.e created by the factory).</p></li><li><p>Stemming: supported through an implementation of interface <code class="classname">com.qizx.api.fulltext.Stemmer</code> .</p><p>No stemmer is officially supported in the distribution. A sample implementation of a Stemmer based on the <a class="ulink" href="???" target="_top">snowball</a> package is available in the API samples.</p><p>Mixing Stemming and Case Sensitivity is not guaranteed to return proper results, as stemmers can fold the case.</p></li><li><p>Thesaurus: supported through an implementation of interface <code class="classname">com.qizx.api.fulltext.Thesaurus</code>.</p><p>No Thesaurus is officially supported in the distribution. A very simple implementation of a Thesaurus is available in the API samples.</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fulltext-migration"></a>3.&nbsp;Migration Guide from former Full-Text implementation</h2></div></div></div><p>When introducing the standard XQuery Full-Text in Qizx 3.0, we have discarded the former full-text facilities based on the extension function ft:contains (also accessible by the name x:fulltext). A radical decision, motivated by the wish to keep Qizx clean and avoid unnecessary legacy.</p><p>To help migrating queries written with the former function ft:contains, a correspondence table is provided here. To help understand this section, it is recommended that you have knowledge of the standard full-text syntax and capabilities. A <a class="link" href="std_fulltext.html#fttutor" title="1.&nbsp;Tutorial Introduction to the standard XQuery Full-Text">tutorial</a> is provided above.</p><div class="table"><a name="d0e3589"></a><p class="title"><b>Table&nbsp;7.1.&nbsp;Correspondence from former full-text</b></p><div class="table-contents"><table summary="Correspondence from former full-text" border="1"><colgroup><col width="20%"><col width="40%"><col width="40%"></colgroup><thead><tr><th align="center">Description</th><th align="center">Former full-text</th><th align="center">Standard full-text</th></tr></thead><tbody><tr><td>Simple term</td><td><pre class="programlisting">//LINE[ ft:contains("Juliet") ]</pre></td><td><pre class="programlisting">//LINE[ . ftcontains "Juliet" ]</pre></td></tr><tr><td>Specify a sub-context</td><td><pre class="programlisting">//SPEECH[ ft:contains("Juliet",
                      SPEAKER)]</pre></td><td><pre class="programlisting">//SPEECH[ SPEAKER 
            ftcontains "Juliet" ]</pre></td></tr><tr><td>All words</td><td><pre class="programlisting">//LINE[ft:contains("Juliet AND romeo")]</pre><pre class="programlisting">//LINE[ft:contains("Juliet romeo")]</pre></td><td><pre class="programlisting">//LINE[ . ftcontains 
          "Juliet romeo" all words]</pre><pre class="programlisting">//LINE[ . ftcontains
          "Juliet" ftand "romeo" ]</pre></td></tr><tr><td>All words (from a computed string sequence)</td><td><pre class="programlisting">declare variable $w := ("Juliet", "romeo");
//SPEECH[ ft:all-words($w) ]</pre></td><td><pre class="programlisting">declare variable $w := ("Juliet", "romeo");
//SPEECH[ . ftcontains { $w } all words]</pre></td></tr><tr><td>Any word in a list</td><td><pre class="programlisting">//LINE[ft:contains(
         "Juliet OR romeo")]</pre></td><td><pre class="programlisting">//LINE[ . ftcontains
          "Juliet romeo" any word]</pre><pre class="programlisting">//LINE[ . ftcontains
          "Juliet" ftor "romeo" ]</pre></td></tr><tr><td>Any word (from a computed string sequence)</td><td><pre class="programlisting">declare variable $w := ("Juliet", "romeo");
//LINE[ ft:any-word($w) ]</pre></td><td><pre class="programlisting">declare variable $w := ("Juliet", "romeo");
//LINE[ . ftcontains { $w } any word ]</pre></td></tr><tr><td>Exclude a word</td><td><pre class="programlisting">//LINE[ft:contains(
          "Juliet AND NOT romeo")]</pre><p>or</p><pre class="programlisting">//LINE[ft:contains("Juliet -Romeo")]</pre></td><td><pre class="programlisting">//LINE[ . ftcontains "Juliet" 
            ftand ftnot "romeo" ]</pre></td></tr><tr><td>Phrase</td><td><pre class="programlisting">//LINE[ft:contains(
          "'to be or not to be'")]</pre></td><td><pre class="programlisting">//LINE[ . ftcontains
            "to be or not to be" ]</pre></td></tr><tr><td>Phrase (from a computed string sequence)</td><td><pre class="programlisting">declare variable $ph :=
        ("to be", "or not", "to be");
//SPEECH[ ft:phrase($ph) ]</pre></td><td><pre class="programlisting">declare variable $ph :=
        ("to be", "or not", "to be");
//SPEECH[ . ftcontains { $ph } phrase ]</pre></td></tr><tr><td>Phrase with window</td><td><pre class="programlisting">//LINE[ft:contains(
         "'to be the question'~10")]</pre></td><td><pre class="programlisting">//LINE[ . ftcontains
            "to be the question"
                 window 10 words ]</pre></td></tr><tr><td>And of Phrases</td><td><pre class="programlisting">//SPEECH[ft:contains(
  "'to be' AND 'to die, to sleep'")]</pre></td><td><pre class="programlisting">//SPEECH[ . ftcontains "to be"
           ftand "to die, to sleep"]</pre></td></tr><tr><td>Or of Phrases</td><td><pre class="programlisting">//SPEECH[ft:contains(
   "'to be' OR 'to die, to sleep'")]</pre></td><td><pre class="programlisting">//SPEECH[ . ftcontains "to be"
            ftor "to die, to sleep"]</pre></td></tr><tr><td>Phrase1 but not phrase2</td><td><pre class="programlisting">//SPEECH[ft:contains(
         " 'to be' NOT 'to die' ")]</pre></td><td><pre class="programlisting">//SPEECH[ . ftcontains "to be" 
              ftand ftnot "to die" ]</pre></td></tr><tr><td>Term with wildcard</td><td><pre class="programlisting">//LINE[ ft:contains("H%let") ]</pre><pre class="programlisting">//LINE[ ft:contains("H_mlet") ]</pre></td><td><pre class="programlisting">//LINE[ . ftcontains "H.*let"
              with wildcards ]</pre><pre class="programlisting">//LINE[ . ftcontains "H.mlet"
              with wildcards ]</pre></td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch06.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="admin_guide.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch08.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;6.&nbsp;Support of standard XQuery Update&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;8.&nbsp;Support of EXPath Packages</td></tr></table></div></body></html>