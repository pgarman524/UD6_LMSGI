<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;17.&nbsp;Java&#8482; Binding</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.1"><link rel="start" href="index.html" title="Qizx Manual"><link rel="up" href="reference.html" title="Part&nbsp;IV.&nbsp;Reference"><link rel="prev" href="ch16.html" title="Chapter&nbsp;16.&nbsp;WebApp extension functions"><link rel="next" href="tools.html" title="Part&nbsp;V.&nbsp;Tools"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;17.&nbsp;<span class="trademark">Java</span>&#8482; Binding</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch16.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;IV.&nbsp;Reference</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="tools.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="java_binding"></a>Chapter&nbsp;17.&nbsp;<span class="trademark">Java</span>&#8482; Binding</h2></div></div></div><p>The<em class="glossterm"> Java binding</em> feature is a powerful extensibility mechanism which allows direct calling of Java methods bound as XQuery functions and manipulation of wrapped Java objects.</p><p>Java Binding opens a tremendous range of possibilities since nearly all the Java APIs become accessible. The implementation performs many automatic conversions, including Java arrays and some Java collections.</p><p>The Java binding mechanism is widely used in several XQuery extension modules such as <em class="glossterm">XML Library handling functions</em> and <em class="glossterm">SQL Connectivity</em>.</p><p>Qizx Java Binding is similar to the mechanism introduced by several other XQuery or XSLT engines like XT or Saxon: a qualified function name where the namespace URI starts with "<code class="literal">java:</code>" is automatically treated as a call to a Java method.</p><div class="itemizedlist"><ul type="disc"><li><p>The namespace URI must be of the form <code class="literal">java:<em class="replaceable"><code>fullyQualifiedClassName</code></em></code>. The designated class will be searched for a method matching the name and arguments of the XQuery function call.</p></li><li><p>The XQuery name of the function is modified as follows: hyphens are removed while the character following an hyphen is upper-cased (producing 'camelCasing'). So "<code class="literal">get-instance</code>" becomes "<code class="literal">getInstance</code>".</p></li></ul></div><p>In the following example the <code class="function">getInstance()</code> method of the class <code class="classname">java.util.Calendar</code> is called:</p><pre class="programlisting">declare namespace cal = "java:java.util.Calendar"
cal:get-instance()    (:  or cal:getInstance()  :)</pre><p>The mechanism is actually a bit more flexible: a namespace can also refer to a package instead of a class name. The class name is passed as a prefix of the function name, separated by a dot. For example:</p><pre class="programlisting">declare namespace util = "java:java.util"
util:Calendar.get-instance()</pre><p>The following example invokes a constructor, gets a wrapped File in variable <code class="varname">$f</code>, then invokes the non-static method <code class="methodname">mkdir()</code>:</p><pre class="programlisting">declare namespace file = "java:java.io.File"

let $f := file:new("mynewdir")   
return file:mkdir($f)  </pre><p>In this example we list the files of the current directory with their sizes and convert the results into XML&nbsp;:</p><pre class="programlisting">declare namespace file = "java:java.io.File"

for $f in file:listFiles( file:new(".") )    (: or list-files() :)
return 
    &lt;file name="{ $f }" size="{ file:length($f) }"/&gt;</pre><div class="variablelist"><dl><dt><span class="term">Security:</span></dt><dd><p>The use of Java Binding in a server environment is a potential security vulnerability. Therefore Java Binding is not allowed by default in the API (applications Qizx Studio and command-line tool enable it).</p><p>Binding can be enabled on a class by class basis. To allow binding of a specific class, use the method <code class="function">enableJavaBinding</code> in interface <code class="classname">XQuerySession</code>.</p></dd><dt><span class="term">Static and instance methods:</span></dt><dd><p>A static Java method must be called with the exact number of parameters of its declaration.</p><p>A non-static method is treated like a static method with an additional first argument ('<code class="literal">this</code>'). The additional first actual argument must of course match the class of the method.</p></dd><dt><span class="term">Constructors:</span></dt><dd><p>A constructor of a class is invoked by using the special function name "<code class="literal">new</code>". A wrapped instance of the class is returned and can be handled in XQuery and passed to other Java functions or to user-defined XQuery functions. For example:</p><pre class="programlisting">declare namespace file = "java:java.io.File";
 file:new("afile.txt") </pre><p>Overloading on constructors is possible in the same way as on other methods.</p></dd><dt><span class="term">Wrapped Java objects</span></dt><dd><p>Bound Java functions can return objects of arbitrary classes which can then be passed as arguments to other functions or stored in variables. The type of such objects is <code class="literal">xdt:object</code> (formerly <code class="literal">xs:wrappedObject</code>). It is always possible to get the string value of such an object (invokes the Java method <code class="methodname">toString()</code>).</p></dd><dt><span class="term">Type conversions:</span></dt><dd><p>Parameters are automatically converted from XQuery types to Java types. Conversely, the return value is converted from Java type to a XQuery type.</p><p>Basic Java types are converted to/from corresponding XQuery basic types.</p><p>Since the XQuery language handles <span class="emphasis"><em>sequences</em></span> of items, special care is given to Java arrays which are mapped to and from XQuery sequences. In addition, a <code class="classname">Vector</code>, <code class="classname">ArrayList</code> or <code class="interfacename">Enumeration</code> returned by a Java method is converted to a XQuery sequence (each element is converted individually to a XQuery object).</p><p>The type conversion chart below details type conversions.</p></dd><dt><span class="term">Overloading</span></dt><dd><p>Overloaded Java methods are partially supported:</p><div class="itemizedlist"><ul type="disc"><li><p>When two Java methods differ by the number of arguments, there is no difficulty. XQuery allows functions with the same name and different numbers of arguments.</p></li><li><p>When two Java methods have the same name and the same number of arguments, there is no absolute guaranty which method will be called, because XQuery is a weakly typed language, so it is not always possible to resolve the method based on static XQuery types (Resolution at run-time would be possible but much more complex and possibly fairly inefficient).</p><p>However, static argument types can be used to find the best matching Java method. For example, assume you bind the following class:</p><pre class="programlisting">class MyClass {
    String myMethod(String sarg) ... 
    int myMethod(double darg) ...
}</pre><p>Then you can call the <code class="function">myMethod</code> (or <code class="function">my-method</code>) function in XQuery with arguments of known static type and be sure which Java method is actually called:</p><pre class="programlisting">declare namespace myc = "java:MyClass"
myc:my-method(1)   (: second Java method is called :)
myc:my-method("string")   (: first Java method is called :)</pre><div class="orderedlist"><ol type="1"><li><p>in the first call, the argument type is <code class="literal">xs:integer</code> for which the closest match is Java <span class="type">double</span>, so the second method is called.</p></li><li><p>In the second call, the argument type is <span class="type">xs:string</span> which matches <code class="classname">String</code> perfectly, so the first method is called.</p></li></ol></div><p>Of course it is possible to use XQuery type declarations, or constructs like <code class="literal">cast as</code> or <code class="literal">treat as</code> to statically specify the type of arguments:</p><pre class="programlisting">declare function local:fun($s as xs:string) {
   myc:my-method($s)   (: first Java method is called :)
}</pre><p>or:</p><pre class="programlisting"> myc:my-method($s treat as xs:string)   (: first Java method is called :)</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Limitations</h3><p>There are still some limitations when in both methods the argument types is any non-mappable Java class (<code class="literal">xdt:object</code> in XQuery):</p></div><pre class="programlisting">class MyClass {
    Object myMethod2(ClassA arg) ... 
    int    myMethod2(ClassB arg) ...
}</pre><p>In that case there is currently no way in Qizx to specify the static type of the actual argument, so the result is unpredictable and may result in a run-time error.</p></li></ul></div></dd></dl></div><div class="table"><a name="d0e14347"></a><p class="title"><b>Table&nbsp;17.1.&nbsp;Types conversions</b></p><div class="table-contents"><table summary="Types conversions" border="1"><colgroup><col width="50%"><col width="50%"></colgroup><thead><tr><th align="center">Java type</th><th align="center">XML Query type</th></tr></thead><tbody><tr><td>void (return type)</td><td>empty()</td></tr><tr><td>String</td><td>xs:string</td></tr><tr><td>boolean, Boolean</td><td>xs:boolean</td></tr><tr><td>double, Double</td><td>xs:double</td></tr><tr><td>float, Float</td><td>xs:float</td></tr><tr><td>java.math.BigDecimal, java.math.BigInteger</td><td>xs:decimal</td></tr><tr><td>long, Long</td><td>xs:integer</td></tr><tr><td>int, Integer</td><td>xs:int</td></tr><tr><td>short, Short</td><td>xs:short</td></tr><tr><td>byte, Byte</td><td>xs:byte</td></tr><tr><td>char, Character</td><td>xs:integer</td></tr><tr><td>com.qizx.api.Node</td><td>node()&nbsp;?</td></tr><tr><td>org.w3c.dom.Node</td><td>node()&nbsp;?</td></tr><tr><td>java.util.Date, java.util.Calendar</td><td>xs:dateTime&nbsp;?</td></tr><tr><td>other class</td><td>xdt:object&nbsp;?</td></tr><tr><td>String[&nbsp;]</td><td>xs:string&nbsp;*</td></tr><tr><td>double[&nbsp;], float[&nbsp;]</td><td>xs:double&nbsp;*</td></tr><tr><td>long[&nbsp;], int[&nbsp;], short[&nbsp;], byte[&nbsp;], char[&nbsp;]</td><td>xs:integer&nbsp;*</td></tr><tr><td>com.qizx.api.Node[&nbsp;]</td><td>node()*</td></tr><tr><td>other array</td><td>xdt:object&nbsp;*</td></tr><tr><td>java.util.Enumeration, java.util.Vector, java.util.ArrayList (<span class="emphasis"><em>return value only</em></span>)</td><td>xdt:object&nbsp;*</td></tr></tbody></table></div></div><br class="table-break"></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch16.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="reference.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="tools.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;16.&nbsp;WebApp extension functions&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;V.&nbsp;Tools</td></tr></table></div></body></html>