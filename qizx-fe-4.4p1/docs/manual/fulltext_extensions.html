<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;13.&nbsp;Full-text XQuery extension functions</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.1"><link rel="start" href="index.html" title="Qizx Manual"><link rel="up" href="reference.html" title="Part&nbsp;IV.&nbsp;Reference"><link rel="prev" href="general_extensions.html" title="Chapter&nbsp;12.&nbsp;General XQuery extension functions"><link rel="next" href="library_extensions.html" title="Chapter&nbsp;14.&nbsp;XML Library extension functions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;13.&nbsp;Full-text XQuery extension functions</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="general_extensions.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;IV.&nbsp;Reference</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="library_extensions.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="fulltext_extensions"></a>Chapter&nbsp;13.&nbsp;Full-text XQuery extension functions</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="fulltext_extensions.html#d0e10800">1. Simplified full-text search</a></span></dt><dd><dl><dt><span class="section"><a href="fulltext_extensions.html#d0e10824">1.1. Definition of the simple full-text syntax</a></span></dt><dt><span class="section"><a href="fulltext_extensions.html#d0e10910">1.2. Search function</a></span></dt></dl></dd><dt><span class="section"><a href="fulltext_extensions.html#d0e11018">2. Other full-text extension functions</a></span></dt><dt><span class="section"><a href="fulltext_extensions.html#d0e11446">3. Examples</a></span></dt></dl></div><p>Starting from version 3.0, Qizx implements the <a class="ulink" href="http://www.w3.org/TR/xpath-full-text-10/" target="_top">standard XQuery Full-Text</a> from the W3C (abbreviated XQFT hereafter).</p><p>Please see chapter <a class="xref" href="std_fulltext.html" title="Chapter&nbsp;7.&nbsp;Support of standard XQuery Full-Text">Standard Full-Text</a> for more information about standard full-text support. That chapter contains a <a class="link" href="std_fulltext.html#fulltext-migration" title="3.&nbsp;Migration Guide from former Full-Text implementation">section</a> explaining how to migrate your Qizx 2.2 applications from the former full-text functionalities.</p><p>This current chapter introduces new full-text extension functions from version 3.1:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>A simplified search function</strong></span> that uses a simpler and more usual query syntax than the XQuery Full-Text standard.</p><p>Note: it is actually similar to the former full-text function (in Qizx 2.2 and before), but beware that the syntax is somewhat different.</p></li><li><p><span class="bold"><strong>Utility functions</strong></span> for highlighting full-text terms, generating summary snippets, looking up indexes and finding spell-checking suggestions.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10800"></a>1.&nbsp;Simplified full-text search</h2></div></div></div><p>The justification for a simplified full-text search facility is the following:</p><div class="itemizedlist"><ul type="disc"><li><p>A standard XQFT query is not an object than can be manipulated by an XQuery script. This makes it more difficult for an XQuery application to synthesize a full-text query and then execute it, unless one resorts to a dynamic evaluation function like Qizx <a class="link" href="general_extensions.html#dyn-eval">x:eval()</a>.</p></li><li><p>The standard XQuery Full-Text from the W3C is not yet a completely stable specification (in July 2009, it reached the stage of <span class="emphasis"><em>Candidate Recommendation</em></span>, and it can take up to one year before it becomes a definitive standard).</p></li><li><p>The standard W3C full-text syntax is a bit complex and unusual, even for advanced users (those users who would otherwise have no difficulty with a query like: <code class="computeroutput">title:product +"beta quality" -alpha</code> ).</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10824"></a>1.1.&nbsp;Definition of the simple full-text syntax</h3></div></div></div><p>This syntax is very simple and resembles the one found in most full-text engines. Notice that there is no notion of Fields, since XQuery itself provides all the means of searching specific parts of XML documents.</p><div class="informaltable"><table border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th align="center">Search Capability</th><th align="center">Examples</th><th align="center">Remarks</th></tr></thead><tbody><tr><td>Simple word (without quotes)</td><td>Hello</td><td><p>Tokenized according to the language and configuration. Note than a composed word like <span class="emphasis"><em>never-ending</em></span> can actually be tokenized into 2 words, equivalent to phrase "never ending".</p></td></tr><tr><td>Wildcard</td><td><p>?ello</p><p>*ell*</p></td><td>Can be used in place of a simple word inside a phrase.</td></tr><tr><td>Phrase (single or double quotes)</td><td><p>"Hello world"</p><p>'Hello, world!'</p></td><td>Tokenized according to the language and configuration.</td></tr><tr><td>Phrase with proximity</td><td>"hello world"~3</td><td>Same meaning as in "window 3 words" of the standard syntax: matches "hello new world", but not "hello brand new world".</td></tr><tr><td>Required term</td><td><p>+world</p><p>+'Hello world'</p></td><td>Acts like a ftand, while plain terms act like a ftor.</td></tr><tr><td>Negated term</td><td><p>-hello</p><p>-"old world"</p></td><td>Such terms must not be found in the searched document or fragment.</td></tr><tr><td>Juxtaposition</td><td>hello "brave new world" +me -you</td><td><p>Terms without + are ORed. Terms with + are ANDed.</p><p>The example on the left is equivalent to: <code class="computeroutput">"me" ftand ("hello" ftor "brave new world") ftand ftnot "you"</code></p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10910"></a>1.2.&nbsp;Search function</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">function ft:contains (<em class="replaceable"><code>$query</code></em>, [<em class="replaceable"><code>$options</code></em>])</pre><pre class="synopsis">function ft:contains (<em class="replaceable"><code>$query</code></em>, <em class="replaceable"><code>$context</code></em>, <em class="replaceable"><code>$options</code></em>)</pre></span></dt><dd><p>returns true if the search context matches the full-text query.</p><p class="remark"><i><span class="remark">Note: this function is similar to the former ft:contains function of Qizx up to version 2.2, but beware that the query syntax is not quite the same.</span></i></p><p>This function is typically used as a <em class="glossterm">predicate</em> in a <em class="glossterm">Path Expression</em>. Examples:</p><pre class="programlisting">//SPEECH[ ft:contains("+romeo +juliet") ],
//SPEECH[ ft:contains(" 'to be or not to be' ", LINE, &lt;options/&gt;) ]</pre><p><b>Returned value:&nbsp;</b>true if the context matches the query, false otherwise.</p><p><b>Parameter <em class="replaceable"><code>$</code></em>query:&nbsp;</b>A query using the simple full-text syntax.</p><p><b>Parameter $context (optional):&nbsp;</b>A node, or sequence of nodes, inside which the full-text expression is searched for. Note: this is the equivalent of a Field in classical full-text engines.</p><p>When <em class="parameter"><code>context</code></em> parameter is not specified, the current context node '.' is used implicitly like in the example above. Note that when the function is called with 2 arguments, the last argument represents the options, not the context.</p><p>When <em class="parameter"><code>context</code></em> parameter is present, it specifies a smaller search domain (in general inside to the current context node) . The 2nd example above finds SPEECH elements which contain at least one LINE element which in turn contains the phrase 'to be or not to be'.</p><p><b>Parameter $options (optional):&nbsp;</b>An element (conventionally named "options") bearing attributes:</p><div class="itemizedlist"><ul type="disc"><li><p>attribute <code class="constant">case</code>: value is "sensitive" or "insensitive" (using only first characters, e.g "sens", is allowed)</p></li><li><p>attribute <code class="constant">diacritics</code>: value is "sensitive" or "insensitive"</p></li><li><p>attribute <code class="constant">language</code>: value is a legal language name, used for tokenizing words and phrases, and stemming. This option must precede stemming and thesaurus options if used (see below).</p></li><li><p>attribute <code class="constant">stemming</code>: value is a boolean "true" or "false". Assumes that the application provides a Stemmer implementation (see the Java API documentation).</p></li><li><p>attribute <code class="constant">thesaurus</code>: value is a thesaurus URI. Assumes that the application provides a Thesaurus implementation (see the API documentation).</p></li></ul></div><p>Example:</p><pre class="programlisting">&lt;options language="fr" diacritics="sensitive"/&gt;</pre></dd></dl></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11018"></a>2.&nbsp;Other full-text extension functions</h2></div></div></div><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">function ft:score (<em class="replaceable"><code>$sequence</code></em>, [<em class="replaceable"><code>$length</code></em>], [<em class="replaceable"><code>$start</code></em>])</pre></span></dt><dd><p>returns the sequence sorted by decreasing full-text score. Optionally, the result sequence can be 'sliced' in pages by specifying the first element and the length of a page.</p><p>The input sequence is typically a full-text search expression using either <code class="literal">ft:contains()</code> or the standard operator '<code class="literal">contains text</code>'.</p><p>The purpose of this function is to simplify the use of scoring, but also to make it more efficient than the `<code class="computeroutput">for score ... order by $score descending</code>' pattern of XQFT standard. Further versions of Qizx could enhance this function to make it even more efficient by allowing fast heuristic scoring strategies.</p><p>When $length and $start are used, this function is an optimized equivalent of:</p><pre class="programlisting">fn:subsequence( for $hit score $score in $sequence
                  order by $score descending
                  return $hit,
                $start, $length )</pre><p>Example:</p><pre class="programlisting">ft:score( //SPEECH[ ft:contains("hello +world") ], 10 )</pre><p><b>Returned value:&nbsp;</b>The input sequence ordered by descending score, possibly sliced.</p><p><b>Parameter <em class="replaceable"><code>$</code></em>sequence:&nbsp;</b>A query using the simple full-text syntax (function ft:contains), or the standard <code class="literal">'contains text'</code> operator.</p><p><b>Parameter $length (optional):&nbsp;</b>Number of results to be returned. Used for slicing results. If not specified, the value is 10.</p><p><b>Parameter $start (optional):&nbsp;</b>rank of the first hit to be returned. Used for slicing results.</p></dd><dt><a name="xfn-highlight"></a><span class="term"><pre class="synopsis">function ft:highlight (<em class="replaceable"><code>$node</code></em>, <em class="replaceable"><code>$query</code></em>, [<em class="replaceable"><code>$options</code></em>]) as node()</pre></span></dt><dd><p>Transforms an XML fragment (document or node) by replacing each occurrence of the words of a full-text query by a XML template that contains the word. This is called highlighting because typically it can be used with a formatting language (HTML) to render the word with some styling, using for example CSS.</p><p>Words within a ftnot clause are not highlighted.</p><p>Word occurrences are highlighted individually. For example if the query specifies a phrase, all occurrences of the words of this phrase will be highlighted, whether they belong to an occurrence of the phrase or not.</p><p>Example:</p><pre class="programlisting">let $doc := &lt;P&gt;this is some text searched by a query.&lt;/P&gt;
return ft:highlight( $doc, "query text", &lt;options word-wrap="B"/&gt; )</pre><p>returns:</p><pre class="programlisting">&lt;P&gt;this is some &lt;B&gt;text&lt;/B&gt; searched by a &lt;B&gt;query&lt;/B&gt;.&lt;/P&gt;</pre><p><b>Returned value:&nbsp;</b>A copy of the node in which all occurrences of the full-text query words are replaced by the specified pattern.</p><p><b>Parameter <em class="replaceable"><code>$node</code></em>:&nbsp;</b>an XML fragment (document or node) to be highlighted.</p><p><b>Parameter <em class="replaceable"><code>$query</code></em>:&nbsp;</b>An expression which is either of:</p><div class="itemizedlist"><ul type="disc"><li><p>The operator <code class="literal">contains text</code>. Example:</p><pre class="programlisting"> ft:highlight($node, . contains text "hello world" any word)</pre><p>Note: the expression must be exactly <code class="literal">'contains text</code>', a boolean combination is not allowed. The context part (here '.') is ignored. Full-text options following <code class="literal">contains text</code> are taken into account.</p></li><li><p>the function ft:contains(). The optional <em class="parameter"><code>context</code></em> argument is ignored. Full-text options are taken into account.</p><pre class="programlisting"> ft:highlight($node, ft:contains(" 'hello world' "))</pre><p>Note: in this example, although the query requires a phrase, all individual occurrences of the words 'hello' and 'world' will be highlighted, not the phrase only.</p></li><li><p>a string (using the simple full-text syntax). In that case it is not possible to specify options.</p><pre class="programlisting"> ft:highlight($node, "hello world")</pre></li></ul></div><p><b>Parameter $options (optional):&nbsp;</b>An element (conventionally named "options") with attributes containing the options. There are two ways of specifying how a word is "highlighted":</p><p>The first way uses a simple element bearing an attribute, similar to the SPAN element of HTML with a class attribute:</p><div class="itemizedlist"><ul type="disc"><li><p>attribute <em class="parameter"><code>word-wrap</code></em>: its value is the name of an element used to wrap the word. Default is "B".</p></li><li><p>optional attribute <em class="parameter"><code>word-style</code></em>: value is the name of an attribute placed on the word-wrapper element. It is not present by default.</p></li><li><p>optional attribute <em class="parameter"><code>word-pattern</code></em>: value is a pattern that is used to give a value to attribute <em class="parameter"><code>word-style</code></em>. If it contains the character %, this character is replaced by the rank of the word in the query.</p><p>Example:</p><pre class="programlisting">let $doc := &lt;P&gt;this is some text searched by a query.&lt;/P&gt;
return ft:highlight( $doc, "xquery +text",
               &lt;options word-wrap="SPAN" word-style="class"
                        word-pattern="hilite%"/&gt; )</pre><p>produces:</p><pre class="programlisting">&lt;P&gt;this is some &lt;SPAN class="hilite1"&gt;text&lt;/SPAN
 &gt; returned by a &lt;SPAN class="hilite0"&gt;XQuery&lt;/SPAN&gt; expression.&lt;/P&gt;</pre></li></ul></div><p>The second way uses a function called by name (XQuery cannot pass a function as a parameter of another function):</p><div class="itemizedlist"><ul type="disc"><li><p>attribute <em class="parameter"><code>word-function</code></em>: value is the name of a function that is called for each occurrence of a word to highlight. The value returned must be a Node which replaces the word.</p><p>The called function must be compatible with this signature:</p><pre class="programlisting">  function($word as xs:string, $word-rank as xs:int, $node as text()):</pre><div class="itemizedlist"><ul type="circle"><li><p>$word receives a string which receives the value of the word</p></li><li><p>$word-rank is an integer which receives the rank of the word in the query.</p></li><li><p>$node is the text node that contains the word. This allows to test arbitrarily complex conditions.</p></li></ul></div><p>Example that highlights a word with bold if it is inside a TITLE, otherwise with a span/class:</p><pre class="programlisting">declare function local:hilite($word, $word-rank, $node) {
  if($node/parent::TITLE) 
  then &lt;B&gt;{$word}&lt;/B&gt;
  else &lt;span class="hilite{$word-rank}"&gt;{$word}&lt;/span&gt;
}

let $doc := &lt;P&gt;this is some text searched by a query.&lt;/P&gt;
return ft:highlight( $doc, . contains text "query text" all words,
            &lt;options word-function="local:hilite"/&gt; )</pre></li></ul></div></dd><dt><span class="term"><pre class="synopsis">function ft:snippet (<em class="replaceable"><code>$node</code></em>, <em class="replaceable"><code>$query</code></em>, [<em class="replaceable"><code>$options</code></em>]) as element()</pre></span></dt><dd><p>Extracts a representative snippet from a document. words from a full-text query are "highlighted" in the same way as the <a class="link" href="fulltext_extensions.html#xfn-highlight">ft:highlight</a> function. This allows getting a result similar to the snippets produced by most major web search engines.</p><p>A snippet is an element that contains text fragments and highlighted words.</p><p>Example:</p><pre class="programlisting">for $doc in //SPEECH[ ft:contains("hello +world") ]
return ft:snippet($doc)</pre><p><b>Returned value:&nbsp;</b>An element node containing the snippet.</p><p><b>Parameter <em class="replaceable"><code>$node</code></em>:&nbsp;</b>an XML document or node to be represented.</p><p><b>Parameter <em class="replaceable"><code>$query</code></em>:&nbsp;</b>A string (simple syntax query) or an expression using contains text, for example <code class="computeroutput">. contains text "hello world"</code>.</p><p><b>Parameter $options (optional):&nbsp;</b>An element (conventionally named "options") with attributes.</p><p>Options similar to <a class="link" href="fulltext_extensions.html#xfn-highlight">ft:highlight</a>:</p><div class="itemizedlist"><ul type="disc"><li><p>attribute <em class="parameter"><code>word-wrap</code></em>: its value is the name of an element used to wrap the word. Default is "B".</p></li><li><p>optional attribute <em class="parameter"><code>word-style</code></em>: value is the name of an attribute placed on the word-wrapper element. It is not present by default.</p></li><li><p>optional attribute <em class="parameter"><code>word-pattern</code></em>: value is a pattern that is used to give a value to attribute <em class="parameter"><code>word-style</code></em>. If it contains the character %, this character is replaced by the rank of the word in the query.</p></li><li><p>attribute <em class="parameter"><code>word-function</code></em>: value is the name of a function that is called for each occurrence of a word to highlight. The value returned must be a Node which replaces the word.</p><p>The called function must be compatible with this signature: function($word as xs:string, $word-rank as xs:int, $node as text()):</p></li></ul></div><p>Specific options:</p><div class="itemizedlist"><ul type="disc"><li><p>attribute <em class="parameter"><code>snippet</code></em>: its value is the name of an element used to wrap the snippet. Default is "snippet".</p></li><li><p>optional attribute <em class="parameter"><code>length</code></em>: the maximum number of words in the snippet. Default value is 20.</p></li><li><p>optional attribute <em class="parameter"><code>work-size</code></em>: the maximum number of words from start examined to find the best parts of the document. Default value is 500.</p></li></ul></div></dd><dt><span class="term"><pre class="synopsis">function ft:word-count(<em class="replaceable"><code>$word as xs:string</code></em>) as xs:integer?</pre></span></dt><dd><p>returns the total count of occurrences of this word in the current XML Library.</p><p>Example:</p><pre class="programlisting">ft:word-count("hamlet") (: counts occurrence of Hamlet, HAMLET etc. :)</pre><p><b>Parameter <em class="replaceable"><code>$word</code></em>:&nbsp;</b>A string containing a single word. Character case and diacritics are not taken into account.</p><p><b>Returned value:&nbsp;</b>An positive integer item, or the null sequence if the word is not found, or if not connected to an XML Library.</p></dd><dt><span class="term"><pre class="synopsis">function ft:word-doc-count(<em class="replaceable"><code>$word as xs:string</code></em>) as xs:integer?</pre></span></dt><dd><p>returns the total count of documents in the current XML Library that contain at least one occurrence of this word.</p><p><b>Parameter <em class="replaceable"><code>$word</code></em>:&nbsp;</b>A string containing a single word. Character case and diacritics are not taken into account.</p><p><b>Returned value:&nbsp;</b>An positive integer item, or the null sequence if the word is not found.</p></dd><dt><span class="term"><pre class="synopsis">function ft:word-lookup([<em class="replaceable"><code>$word-pattern as xs:string?</code></em>]) as xs:string*</pre></span></dt><dd><p>returns a list of words indexed in the current XML Library that match the pattern. If no pattern is passed, then all the words indexed in the Library are returned.</p><p>Attention: words are sorted ignoring character case and diacritics, and the different forms in which a word occurs are not returned. For example <code class="computeroutput">ft:word-lookup("cafe")</code> does not return a sequence <code class="computeroutput">like ("CAFE", "CAF&Eacute;", "Cafe", "Caf&eacute;", "cafe", "caf&eacute;")</code> even if these forms occur in the XML Library. This situation is likely to change in later versions, which will optimize case-sensitive and diacritics-sensitive searches, but that will require to change the representation of indexes.</p><p><b>Parameter <em class="replaceable"><code>$word-pattern</code></em>:&nbsp;</b>A string containing a wildcard pattern (standard syntax, case and diacritics insensitive). If absent, then all the words indexed in the Library are listed.</p><p><b>Returned value:&nbsp;</b>A sorted list of strings, or the null sequence if the word is not found. Sorting is done ignoring character case and diacritics.</p></dd><dt><span class="term"><pre class="synopsis">function ft:suggest(<em class="replaceable"><code>$word as xs:string</code></em>) as xs:string*</pre></span></dt><dd><p>returns a list of words that are "close to" the specified word, sorted by increasing distance. The distance used is a simple Levenshtein algorithm, where differences in case or diacritics have a lesser weight than deletion or insertions. The function also tries space insertion (e.g "myword" can yield "my word").</p><p>Note: this function is not a spell-checking facility, it can only return words that actually appear in a document of the Library.</p><p><b>Parameter <em class="replaceable"><code>$word</code></em>:&nbsp;</b>A string containing a single word. Character case and diacritics are taken into account for distance calculation.</p><p><b>Returned value:&nbsp;</b>A string sequence containing at most 20 suggestions. Best effort is done for returning at least one suggestion.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11446"></a>3.&nbsp;Examples</h2></div></div></div><p>This section is a short tutorial showing how to use Qizx full-text functionalities.</p><h3><a name="d0e11451"></a>Query a collection of documents:</h3><p>The most classical way of doing full-text queries is to look for whole documents matching a full-text expression anywhere in their contents. For example, using standard XQuery Full-Text:</p><pre class="programlisting">/*[ . contains text "printing press" ] (: uses implicit collection :)</pre><p>or the same using the simplified syntax:</p><pre class="programlisting">/*[ ft:contains(" 'printing press' ") ]  (: notice the quotes :)</pre><p>The 2 examples above return a sequence of the root elements of the matching documents. If you want to retrieve the Document objects themselves, use xlib:document():</p><pre class="programlisting">for $doc in /*[ . contains text "printing press" ]
 return xlib:document($doc)</pre><h3><a name="d0e11465"></a>"Advanced Search" a la Google&#8482;:</h3><p>The <a class="ulink" href="http://www.google.com/advanced_search" target="_top">Advanced Search by Google</a> offers the possibility to search for pages that match "all these words", "this exact wording or phrase", "one or more of these words", but not pages that have "any of these unwanted words" (words are specified in form fields).</p><p>This is easy to implement with XQFT and Qizx, assuming that you have the field values in 4 variables named $all, $exact, $any, $unwanted:</p><pre class="programlisting">/*[ . contains text
      { $all } all words ftand
      { $any } any word ftand
      { $exact } phrase ftand 
      ftnot { $unwanted } any word
  ]</pre><p>Note that if all fields are empty, no error is detected but no document is returned.</p><h3><a name="d0e11478"></a>Find best scoring documents:</h3><p>The function ft:score is designed to make easier to finding best scoring documents and list them in pages. To display the first 10 documents matching a query:</p><pre class="programlisting">ft:score( /*[ . contains text "printing press" ] , 10)</pre><p>To display the following 10 documents by descending score, just increment a variable $start (initialized to 0) by 10 and use it as third argument of</p><pre class="programlisting">ft:score( /*[ . contains text "printing press" ] , 10, $start)</pre><h3><a name="d0e11488"></a>Display summary snippets of documents:</h3><p>Popular web search engines display a short abstract of each document showing highlighted terms of the full-text query. The function ft:snippet allows to do this easily in Qizx:</p><pre class="programlisting">let $query := "printing press" 
for $doc in /*[ . contains text { $query } ]
 return ft:snippet($doc, $query)</pre><p>The output of ft:snippet and ft:highlight functions can be controlled finely (see the reference documentation).</p><h3><a name="d0e11496"></a>Summary: a simple "Advanced Search"</h3><p>This query finds the 10 best matching documents, and for each document returns a snippet where the query terms are in bold:</p><pre class="programlisting">for $doc in 
   ft:score(/*[ . contains text
                { $all } all words ftand
                { $any } any word ftand
                { $exact } phrase ftand 
                ftnot { $unwanted } any word ], 10)
return
  &lt;div&gt;&lt;h4&gt;{ xlib:document($doc) }&lt;/h4&gt;
       { ft:snippet($doc,
                    . contains text { $all } all words ftand
                                    { $any } any word ftand
                                    { $exact } phrase,
                    &lt;options word-wrap="b"/&gt;)
       }&lt;/div&gt;</pre><p></p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="general_extensions.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="reference.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="library_extensions.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;12.&nbsp;General XQuery extension functions&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;14.&nbsp;XML Library extension functions</td></tr></table></div></body></html>